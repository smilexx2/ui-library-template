"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ts-interface-checker";
exports.ids = ["vendor-chunks/ts-interface-checker"];
exports.modules = {

/***/ "(ssr)/./node_modules/ts-interface-checker/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ts-interface-checker/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Checker = exports.createCheckers = void 0;\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ts-interface-checker/dist/types.js\");\nvar util_1 = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/ts-interface-checker/dist/util.js\");\n/**\n * Export functions used to define interfaces.\n */\nvar types_2 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ts-interface-checker/dist/types.js\");\nObject.defineProperty(exports, \"TArray\", ({ enumerable: true, get: function () { return types_2.TArray; } }));\nObject.defineProperty(exports, \"TEnumType\", ({ enumerable: true, get: function () { return types_2.TEnumType; } }));\nObject.defineProperty(exports, \"TEnumLiteral\", ({ enumerable: true, get: function () { return types_2.TEnumLiteral; } }));\nObject.defineProperty(exports, \"TFunc\", ({ enumerable: true, get: function () { return types_2.TFunc; } }));\nObject.defineProperty(exports, \"TIface\", ({ enumerable: true, get: function () { return types_2.TIface; } }));\nObject.defineProperty(exports, \"TLiteral\", ({ enumerable: true, get: function () { return types_2.TLiteral; } }));\nObject.defineProperty(exports, \"TName\", ({ enumerable: true, get: function () { return types_2.TName; } }));\nObject.defineProperty(exports, \"TOptional\", ({ enumerable: true, get: function () { return types_2.TOptional; } }));\nObject.defineProperty(exports, \"TParam\", ({ enumerable: true, get: function () { return types_2.TParam; } }));\nObject.defineProperty(exports, \"TParamList\", ({ enumerable: true, get: function () { return types_2.TParamList; } }));\nObject.defineProperty(exports, \"TProp\", ({ enumerable: true, get: function () { return types_2.TProp; } }));\nObject.defineProperty(exports, \"TTuple\", ({ enumerable: true, get: function () { return types_2.TTuple; } }));\nObject.defineProperty(exports, \"TType\", ({ enumerable: true, get: function () { return types_2.TType; } }));\nObject.defineProperty(exports, \"TUnion\", ({ enumerable: true, get: function () { return types_2.TUnion; } }));\nObject.defineProperty(exports, \"TIntersection\", ({ enumerable: true, get: function () { return types_2.TIntersection; } }));\nObject.defineProperty(exports, \"array\", ({ enumerable: true, get: function () { return types_2.array; } }));\nObject.defineProperty(exports, \"enumlit\", ({ enumerable: true, get: function () { return types_2.enumlit; } }));\nObject.defineProperty(exports, \"enumtype\", ({ enumerable: true, get: function () { return types_2.enumtype; } }));\nObject.defineProperty(exports, \"func\", ({ enumerable: true, get: function () { return types_2.func; } }));\nObject.defineProperty(exports, \"iface\", ({ enumerable: true, get: function () { return types_2.iface; } }));\nObject.defineProperty(exports, \"lit\", ({ enumerable: true, get: function () { return types_2.lit; } }));\nObject.defineProperty(exports, \"name\", ({ enumerable: true, get: function () { return types_2.name; } }));\nObject.defineProperty(exports, \"opt\", ({ enumerable: true, get: function () { return types_2.opt; } }));\nObject.defineProperty(exports, \"param\", ({ enumerable: true, get: function () { return types_2.param; } }));\nObject.defineProperty(exports, \"tuple\", ({ enumerable: true, get: function () { return types_2.tuple; } }));\nObject.defineProperty(exports, \"union\", ({ enumerable: true, get: function () { return types_2.union; } }));\nObject.defineProperty(exports, \"intersection\", ({ enumerable: true, get: function () { return types_2.intersection; } }));\nObject.defineProperty(exports, \"BasicType\", ({ enumerable: true, get: function () { return types_2.BasicType; } }));\nvar util_2 = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/ts-interface-checker/dist/util.js\");\nObject.defineProperty(exports, \"VError\", ({ enumerable: true, get: function () { return util_2.VError; } }));\n/**\n * Takes one of more type suites (e.g. a module generated by `ts-interface-builder`), and combines\n * them into a suite of interface checkers. If a type is used by name, that name should be present\n * among the passed-in type suites.\n *\n * The returned object maps type names to Checker objects.\n */\nfunction createCheckers() {\n    var typeSuite = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSuite[_i] = arguments[_i];\n    }\n    var fullSuite = Object.assign.apply(Object, __spreadArrays([{}, types_1.basicTypes], typeSuite));\n    var checkers = {};\n    for (var _a = 0, typeSuite_1 = typeSuite; _a < typeSuite_1.length; _a++) {\n        var suite_1 = typeSuite_1[_a];\n        for (var _b = 0, _c = Object.keys(suite_1); _b < _c.length; _b++) {\n            var name = _c[_b];\n            checkers[name] = new Checker(fullSuite, suite_1[name]);\n        }\n    }\n    return checkers;\n}\nexports.createCheckers = createCheckers;\n/**\n * Checker implements validation of objects, and also includes accessors to validate method calls.\n * Checkers should be created using `createCheckers()`.\n */\nvar Checker = /** @class */ (function () {\n    // Create checkers by using `createCheckers()` function.\n    function Checker(suite, ttype, _path) {\n        if (_path === void 0) { _path = 'value'; }\n        this.suite = suite;\n        this.ttype = ttype;\n        this._path = _path;\n        this.props = new Map();\n        if (ttype instanceof types_1.TIface) {\n            for (var _i = 0, _a = ttype.props; _i < _a.length; _i++) {\n                var p = _a[_i];\n                this.props.set(p.name, p.ttype);\n            }\n        }\n        this.checkerPlain = this.ttype.getChecker(suite, false);\n        this.checkerStrict = this.ttype.getChecker(suite, true);\n    }\n    /**\n     * Set the path to report in errors, instead of the default \"value\". (E.g. if the Checker is for\n     * a \"person\" interface, set path to \"person\" to report e.g. \"person.name is not a string\".)\n     */\n    Checker.prototype.setReportedPath = function (path) {\n        this._path = path;\n    };\n    /**\n     * Check that the given value satisfies this checker's type, or throw Error.\n     */\n    Checker.prototype.check = function (value) { return this._doCheck(this.checkerPlain, value); };\n    /**\n     * A fast check for whether or not the given value satisfies this Checker's type. This returns\n     * true or false, does not produce an error message, and is fast both on success and on failure.\n     */\n    Checker.prototype.test = function (value) {\n        return this.checkerPlain(value, new util_1.NoopContext());\n    };\n    /**\n     * Returns an error object describing the errors if the given value does not satisfy this\n     * Checker's type, or null if it does.\n     */\n    Checker.prototype.validate = function (value) {\n        return this._doValidate(this.checkerPlain, value);\n    };\n    /**\n     * Check that the given value satisfies this checker's type strictly. This checks that objects\n     * and tuples have no extra members. Note that this prevents backward compatibility, so usually\n     * a plain check() is more appropriate.\n     */\n    Checker.prototype.strictCheck = function (value) { return this._doCheck(this.checkerStrict, value); };\n    /**\n     * A fast strict check for whether or not the given value satisfies this Checker's type. Returns\n     * true or false, does not produce an error message, and is fast both on success and on failure.\n     */\n    Checker.prototype.strictTest = function (value) {\n        return this.checkerStrict(value, new util_1.NoopContext());\n    };\n    /**\n     * Returns an error object describing the errors if the given value does not satisfy this\n     * Checker's type strictly, or null if it does.\n     */\n    Checker.prototype.strictValidate = function (value) {\n        return this._doValidate(this.checkerStrict, value);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the type required for the given\n     * property of this interface.\n     */\n    Checker.prototype.getProp = function (prop) {\n        var ttype = this.props.get(prop);\n        if (!ttype) {\n            throw new Error(\"Type has no property \" + prop);\n        }\n        return new Checker(this.suite, ttype, this._path + \".\" + prop);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the argument-list required to call\n     * the given method of this interface. E.g. if this Checker is for the interface:\n     *    interface Foo {\n     *      find(s: string, pos?: number): number;\n     *    }\n     * Then methodArgs(\"find\").check(...) will succeed for [\"foo\"] and [\"foo\", 3], but not for [17].\n     */\n    Checker.prototype.methodArgs = function (methodName) {\n        var tfunc = this._getMethod(methodName);\n        return new Checker(this.suite, tfunc.paramList);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the return value of the given\n     * method of this interface.\n     */\n    Checker.prototype.methodResult = function (methodName) {\n        var tfunc = this._getMethod(methodName);\n        return new Checker(this.suite, tfunc.result);\n    };\n    /**\n     * If this checker is for a function, returns a Checker for its argument-list.\n     */\n    Checker.prototype.getArgs = function () {\n        if (!(this.ttype instanceof types_1.TFunc)) {\n            throw new Error(\"getArgs() applied to non-function\");\n        }\n        return new Checker(this.suite, this.ttype.paramList);\n    };\n    /**\n     * If this checker is for a function, returns a Checker for its result.\n     */\n    Checker.prototype.getResult = function () {\n        if (!(this.ttype instanceof types_1.TFunc)) {\n            throw new Error(\"getResult() applied to non-function\");\n        }\n        return new Checker(this.suite, this.ttype.result);\n    };\n    /**\n     * Return the type for which this is a checker.\n     */\n    Checker.prototype.getType = function () {\n        return this.ttype;\n    };\n    /**\n     * Actual implementation of check() and strictCheck().\n     */\n    Checker.prototype._doCheck = function (checkerFunc, value) {\n        var noopCtx = new util_1.NoopContext();\n        if (!checkerFunc(value, noopCtx)) {\n            var detailCtx = new util_1.DetailContext();\n            checkerFunc(value, detailCtx);\n            throw detailCtx.getError(this._path);\n        }\n    };\n    Checker.prototype._doValidate = function (checkerFunc, value) {\n        var noopCtx = new util_1.NoopContext();\n        if (checkerFunc(value, noopCtx)) {\n            return null;\n        }\n        var detailCtx = new util_1.DetailContext();\n        checkerFunc(value, detailCtx);\n        return detailCtx.getErrorDetail(this._path);\n    };\n    Checker.prototype._getMethod = function (methodName) {\n        var ttype = this.props.get(methodName);\n        if (!ttype) {\n            throw new Error(\"Type has no property \" + methodName);\n        }\n        if (!(ttype instanceof types_1.TFunc)) {\n            throw new Error(\"Property \" + methodName + \" is not a method\");\n        }\n        return ttype;\n    };\n    return Checker;\n}());\nexports.Checker = Checker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHMtaW50ZXJmYWNlLWNoZWNrZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQseUNBQXlDLFFBQVE7QUFDakQseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxzQkFBc0I7QUFDeEMsY0FBYyxtQkFBTyxDQUFDLHdFQUFTO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxzRUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsd0VBQVM7QUFDL0IsMENBQXlDLEVBQUUscUNBQXFDLDBCQUEwQixFQUFDO0FBQzNHLDZDQUE0QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUNqSCxnREFBK0MsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdkgseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLDBDQUF5QyxFQUFFLHFDQUFxQywwQkFBMEIsRUFBQztBQUMzRyw0Q0FBMkMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDL0cseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLDZDQUE0QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUNqSCwwQ0FBeUMsRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUM7QUFDM0csOENBQTZDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ25ILHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6RywwQ0FBeUMsRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUM7QUFDM0cseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLDBDQUF5QyxFQUFFLHFDQUFxQywwQkFBMEIsRUFBQztBQUMzRyxpREFBZ0QsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDekgseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLDJDQUEwQyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM3Ryw0Q0FBMkMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDL0csd0NBQXVDLEVBQUUscUNBQXFDLHdCQUF3QixFQUFDO0FBQ3ZHLHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6Ryx1Q0FBc0MsRUFBRSxxQ0FBcUMsdUJBQXVCLEVBQUM7QUFDckcsd0NBQXVDLEVBQUUscUNBQXFDLHdCQUF3QixFQUFDO0FBQ3ZHLHVDQUFzQyxFQUFFLHFDQUFxQyx1QkFBdUIsRUFBQztBQUNyRyx5Q0FBd0MsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDekcseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6RyxnREFBK0MsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdkgsNkNBQTRDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ2pILGFBQWEsbUJBQU8sQ0FBQyxzRUFBUTtBQUM3QiwwQ0FBeUMsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWxpYnJhcnktZG9jcy8uL25vZGVfbW9kdWxlcy90cy1pbnRlcmZhY2UtY2hlY2tlci9kaXN0L2luZGV4LmpzPzE0OTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hlY2tlciA9IGV4cG9ydHMuY3JlYXRlQ2hlY2tlcnMgPSB2b2lkIDA7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG4vKipcbiAqIEV4cG9ydCBmdW5jdGlvbnMgdXNlZCB0byBkZWZpbmUgaW50ZXJmYWNlcy5cbiAqL1xudmFyIHR5cGVzXzIgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5UQXJyYXk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJURW51bVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIuVEVudW1UeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVEVudW1MaXRlcmFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlRFbnVtTGl0ZXJhbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRGdW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlRGdW5jOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVElmYWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlRJZmFjZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRMaXRlcmFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlRMaXRlcmFsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVE5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIuVE5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUT3B0aW9uYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIuVE9wdGlvbmFsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFBhcmFtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlRQYXJhbTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRQYXJhbUxpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIuVFBhcmFtTGlzdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRQcm9wXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlRQcm9wOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFR1cGxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlRUdXBsZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlRUeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFVuaW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlRVbmlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRJbnRlcnNlY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIuVEludGVyc2VjdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLmFycmF5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW51bWxpdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5lbnVtbGl0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW51bXR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIuZW51bXR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmdW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLmZ1bmM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpZmFjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5pZmFjZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxpdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5saXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLm5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvcHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIub3B0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyYW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIucGFyYW07IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0dXBsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi50dXBsZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVuaW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLnVuaW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW50ZXJzZWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLmludGVyc2VjdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2ljVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5CYXNpY1R5cGU7IH0gfSk7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbF8yLlZFcnJvcjsgfSB9KTtcbi8qKlxuICogVGFrZXMgb25lIG9mIG1vcmUgdHlwZSBzdWl0ZXMgKGUuZy4gYSBtb2R1bGUgZ2VuZXJhdGVkIGJ5IGB0cy1pbnRlcmZhY2UtYnVpbGRlcmApLCBhbmQgY29tYmluZXNcbiAqIHRoZW0gaW50byBhIHN1aXRlIG9mIGludGVyZmFjZSBjaGVja2Vycy4gSWYgYSB0eXBlIGlzIHVzZWQgYnkgbmFtZSwgdGhhdCBuYW1lIHNob3VsZCBiZSBwcmVzZW50XG4gKiBhbW9uZyB0aGUgcGFzc2VkLWluIHR5cGUgc3VpdGVzLlxuICpcbiAqIFRoZSByZXR1cm5lZCBvYmplY3QgbWFwcyB0eXBlIG5hbWVzIHRvIENoZWNrZXIgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hlY2tlcnMoKSB7XG4gICAgdmFyIHR5cGVTdWl0ZSA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHR5cGVTdWl0ZVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgZnVsbFN1aXRlID0gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIF9fc3ByZWFkQXJyYXlzKFt7fSwgdHlwZXNfMS5iYXNpY1R5cGVzXSwgdHlwZVN1aXRlKSk7XG4gICAgdmFyIGNoZWNrZXJzID0ge307XG4gICAgZm9yICh2YXIgX2EgPSAwLCB0eXBlU3VpdGVfMSA9IHR5cGVTdWl0ZTsgX2EgPCB0eXBlU3VpdGVfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIHN1aXRlXzEgPSB0eXBlU3VpdGVfMVtfYV07XG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBPYmplY3Qua2V5cyhzdWl0ZV8xKTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2NbX2JdO1xuICAgICAgICAgICAgY2hlY2tlcnNbbmFtZV0gPSBuZXcgQ2hlY2tlcihmdWxsU3VpdGUsIHN1aXRlXzFbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGVja2Vycztcbn1cbmV4cG9ydHMuY3JlYXRlQ2hlY2tlcnMgPSBjcmVhdGVDaGVja2Vycztcbi8qKlxuICogQ2hlY2tlciBpbXBsZW1lbnRzIHZhbGlkYXRpb24gb2Ygb2JqZWN0cywgYW5kIGFsc28gaW5jbHVkZXMgYWNjZXNzb3JzIHRvIHZhbGlkYXRlIG1ldGhvZCBjYWxscy5cbiAqIENoZWNrZXJzIHNob3VsZCBiZSBjcmVhdGVkIHVzaW5nIGBjcmVhdGVDaGVja2VycygpYC5cbiAqL1xudmFyIENoZWNrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ3JlYXRlIGNoZWNrZXJzIGJ5IHVzaW5nIGBjcmVhdGVDaGVja2VycygpYCBmdW5jdGlvbi5cbiAgICBmdW5jdGlvbiBDaGVja2VyKHN1aXRlLCB0dHlwZSwgX3BhdGgpIHtcbiAgICAgICAgaWYgKF9wYXRoID09PSB2b2lkIDApIHsgX3BhdGggPSAndmFsdWUnOyB9XG4gICAgICAgIHRoaXMuc3VpdGUgPSBzdWl0ZTtcbiAgICAgICAgdGhpcy50dHlwZSA9IHR0eXBlO1xuICAgICAgICB0aGlzLl9wYXRoID0gX3BhdGg7XG4gICAgICAgIHRoaXMucHJvcHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmICh0dHlwZSBpbnN0YW5jZW9mIHR5cGVzXzEuVElmYWNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdHR5cGUucHJvcHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zZXQocC5uYW1lLCBwLnR0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrZXJQbGFpbiA9IHRoaXMudHR5cGUuZ2V0Q2hlY2tlcihzdWl0ZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmNoZWNrZXJTdHJpY3QgPSB0aGlzLnR0eXBlLmdldENoZWNrZXIoc3VpdGUsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBhdGggdG8gcmVwb3J0IGluIGVycm9ycywgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBcInZhbHVlXCIuIChFLmcuIGlmIHRoZSBDaGVja2VyIGlzIGZvclxuICAgICAqIGEgXCJwZXJzb25cIiBpbnRlcmZhY2UsIHNldCBwYXRoIHRvIFwicGVyc29uXCIgdG8gcmVwb3J0IGUuZy4gXCJwZXJzb24ubmFtZSBpcyBub3QgYSBzdHJpbmdcIi4pXG4gICAgICovXG4gICAgQ2hlY2tlci5wcm90b3R5cGUuc2V0UmVwb3J0ZWRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgdGhpcyBjaGVja2VyJ3MgdHlwZSwgb3IgdGhyb3cgRXJyb3IuXG4gICAgICovXG4gICAgQ2hlY2tlci5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuX2RvQ2hlY2sodGhpcy5jaGVja2VyUGxhaW4sIHZhbHVlKTsgfTtcbiAgICAvKipcbiAgICAgKiBBIGZhc3QgY2hlY2sgZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgdGhpcyBDaGVja2VyJ3MgdHlwZS4gVGhpcyByZXR1cm5zXG4gICAgICogdHJ1ZSBvciBmYWxzZSwgZG9lcyBub3QgcHJvZHVjZSBhbiBlcnJvciBtZXNzYWdlLCBhbmQgaXMgZmFzdCBib3RoIG9uIHN1Y2Nlc3MgYW5kIG9uIGZhaWx1cmUuXG4gICAgICovXG4gICAgQ2hlY2tlci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja2VyUGxhaW4odmFsdWUsIG5ldyB1dGlsXzEuTm9vcENvbnRleHQoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVycm9yIG9iamVjdCBkZXNjcmliaW5nIHRoZSBlcnJvcnMgaWYgdGhlIGdpdmVuIHZhbHVlIGRvZXMgbm90IHNhdGlzZnkgdGhpc1xuICAgICAqIENoZWNrZXIncyB0eXBlLCBvciBudWxsIGlmIGl0IGRvZXMuXG4gICAgICovXG4gICAgQ2hlY2tlci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvVmFsaWRhdGUodGhpcy5jaGVja2VyUGxhaW4sIHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIGdpdmVuIHZhbHVlIHNhdGlzZmllcyB0aGlzIGNoZWNrZXIncyB0eXBlIHN0cmljdGx5LiBUaGlzIGNoZWNrcyB0aGF0IG9iamVjdHNcbiAgICAgKiBhbmQgdHVwbGVzIGhhdmUgbm8gZXh0cmEgbWVtYmVycy4gTm90ZSB0aGF0IHRoaXMgcHJldmVudHMgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgc28gdXN1YWxseVxuICAgICAqIGEgcGxhaW4gY2hlY2soKSBpcyBtb3JlIGFwcHJvcHJpYXRlLlxuICAgICAqL1xuICAgIENoZWNrZXIucHJvdG90eXBlLnN0cmljdENoZWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9kb0NoZWNrKHRoaXMuY2hlY2tlclN0cmljdCwgdmFsdWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEEgZmFzdCBzdHJpY3QgY2hlY2sgZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgdGhpcyBDaGVja2VyJ3MgdHlwZS4gUmV0dXJuc1xuICAgICAqIHRydWUgb3IgZmFsc2UsIGRvZXMgbm90IHByb2R1Y2UgYW4gZXJyb3IgbWVzc2FnZSwgYW5kIGlzIGZhc3QgYm90aCBvbiBzdWNjZXNzIGFuZCBvbiBmYWlsdXJlLlxuICAgICAqL1xuICAgIENoZWNrZXIucHJvdG90eXBlLnN0cmljdFRlc3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tlclN0cmljdCh2YWx1ZSwgbmV3IHV0aWxfMS5Ob29wQ29udGV4dCgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZXJyb3Igb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGVycm9ycyBpZiB0aGUgZ2l2ZW4gdmFsdWUgZG9lcyBub3Qgc2F0aXNmeSB0aGlzXG4gICAgICogQ2hlY2tlcidzIHR5cGUgc3RyaWN0bHksIG9yIG51bGwgaWYgaXQgZG9lcy5cbiAgICAgKi9cbiAgICBDaGVja2VyLnByb3RvdHlwZS5zdHJpY3RWYWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9WYWxpZGF0ZSh0aGlzLmNoZWNrZXJTdHJpY3QsIHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgY2hlY2tlciBpcyBmb3IgYW4gaW50ZXJmYWNlLCByZXR1cm5zIGEgQ2hlY2tlciBmb3IgdGhlIHR5cGUgcmVxdWlyZWQgZm9yIHRoZSBnaXZlblxuICAgICAqIHByb3BlcnR5IG9mIHRoaXMgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIENoZWNrZXIucHJvdG90eXBlLmdldFByb3AgPSBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICB2YXIgdHR5cGUgPSB0aGlzLnByb3BzLmdldChwcm9wKTtcbiAgICAgICAgaWYgKCF0dHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBoYXMgbm8gcHJvcGVydHkgXCIgKyBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoZWNrZXIodGhpcy5zdWl0ZSwgdHR5cGUsIHRoaXMuX3BhdGggKyBcIi5cIiArIHByb3ApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBjaGVja2VyIGlzIGZvciBhbiBpbnRlcmZhY2UsIHJldHVybnMgYSBDaGVja2VyIGZvciB0aGUgYXJndW1lbnQtbGlzdCByZXF1aXJlZCB0byBjYWxsXG4gICAgICogdGhlIGdpdmVuIG1ldGhvZCBvZiB0aGlzIGludGVyZmFjZS4gRS5nLiBpZiB0aGlzIENoZWNrZXIgaXMgZm9yIHRoZSBpbnRlcmZhY2U6XG4gICAgICogICAgaW50ZXJmYWNlIEZvbyB7XG4gICAgICogICAgICBmaW5kKHM6IHN0cmluZywgcG9zPzogbnVtYmVyKTogbnVtYmVyO1xuICAgICAqICAgIH1cbiAgICAgKiBUaGVuIG1ldGhvZEFyZ3MoXCJmaW5kXCIpLmNoZWNrKC4uLikgd2lsbCBzdWNjZWVkIGZvciBbXCJmb29cIl0gYW5kIFtcImZvb1wiLCAzXSwgYnV0IG5vdCBmb3IgWzE3XS5cbiAgICAgKi9cbiAgICBDaGVja2VyLnByb3RvdHlwZS5tZXRob2RBcmdzID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIHRmdW5jID0gdGhpcy5fZ2V0TWV0aG9kKG1ldGhvZE5hbWUpO1xuICAgICAgICByZXR1cm4gbmV3IENoZWNrZXIodGhpcy5zdWl0ZSwgdGZ1bmMucGFyYW1MaXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgY2hlY2tlciBpcyBmb3IgYW4gaW50ZXJmYWNlLCByZXR1cm5zIGEgQ2hlY2tlciBmb3IgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBtZXRob2Qgb2YgdGhpcyBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgQ2hlY2tlci5wcm90b3R5cGUubWV0aG9kUmVzdWx0ID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIHRmdW5jID0gdGhpcy5fZ2V0TWV0aG9kKG1ldGhvZE5hbWUpO1xuICAgICAgICByZXR1cm4gbmV3IENoZWNrZXIodGhpcy5zdWl0ZSwgdGZ1bmMucmVzdWx0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgY2hlY2tlciBpcyBmb3IgYSBmdW5jdGlvbiwgcmV0dXJucyBhIENoZWNrZXIgZm9yIGl0cyBhcmd1bWVudC1saXN0LlxuICAgICAqL1xuICAgIENoZWNrZXIucHJvdG90eXBlLmdldEFyZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghKHRoaXMudHR5cGUgaW5zdGFuY2VvZiB0eXBlc18xLlRGdW5jKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0QXJncygpIGFwcGxpZWQgdG8gbm9uLWZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hlY2tlcih0aGlzLnN1aXRlLCB0aGlzLnR0eXBlLnBhcmFtTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGNoZWNrZXIgaXMgZm9yIGEgZnVuY3Rpb24sIHJldHVybnMgYSBDaGVja2VyIGZvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIENoZWNrZXIucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCEodGhpcy50dHlwZSBpbnN0YW5jZW9mIHR5cGVzXzEuVEZ1bmMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRSZXN1bHQoKSBhcHBsaWVkIHRvIG5vbi1mdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoZWNrZXIodGhpcy5zdWl0ZSwgdGhpcy50dHlwZS5yZXN1bHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB0eXBlIGZvciB3aGljaCB0aGlzIGlzIGEgY2hlY2tlci5cbiAgICAgKi9cbiAgICBDaGVja2VyLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50dHlwZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFjdHVhbCBpbXBsZW1lbnRhdGlvbiBvZiBjaGVjaygpIGFuZCBzdHJpY3RDaGVjaygpLlxuICAgICAqL1xuICAgIENoZWNrZXIucHJvdG90eXBlLl9kb0NoZWNrID0gZnVuY3Rpb24gKGNoZWNrZXJGdW5jLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbm9vcEN0eCA9IG5ldyB1dGlsXzEuTm9vcENvbnRleHQoKTtcbiAgICAgICAgaWYgKCFjaGVja2VyRnVuYyh2YWx1ZSwgbm9vcEN0eCkpIHtcbiAgICAgICAgICAgIHZhciBkZXRhaWxDdHggPSBuZXcgdXRpbF8xLkRldGFpbENvbnRleHQoKTtcbiAgICAgICAgICAgIGNoZWNrZXJGdW5jKHZhbHVlLCBkZXRhaWxDdHgpO1xuICAgICAgICAgICAgdGhyb3cgZGV0YWlsQ3R4LmdldEVycm9yKHRoaXMuX3BhdGgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGVja2VyLnByb3RvdHlwZS5fZG9WYWxpZGF0ZSA9IGZ1bmN0aW9uIChjaGVja2VyRnVuYywgdmFsdWUpIHtcbiAgICAgICAgdmFyIG5vb3BDdHggPSBuZXcgdXRpbF8xLk5vb3BDb250ZXh0KCk7XG4gICAgICAgIGlmIChjaGVja2VyRnVuYyh2YWx1ZSwgbm9vcEN0eCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZXRhaWxDdHggPSBuZXcgdXRpbF8xLkRldGFpbENvbnRleHQoKTtcbiAgICAgICAgY2hlY2tlckZ1bmModmFsdWUsIGRldGFpbEN0eCk7XG4gICAgICAgIHJldHVybiBkZXRhaWxDdHguZ2V0RXJyb3JEZXRhaWwodGhpcy5fcGF0aCk7XG4gICAgfTtcbiAgICBDaGVja2VyLnByb3RvdHlwZS5fZ2V0TWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIHR0eXBlID0gdGhpcy5wcm9wcy5nZXQobWV0aG9kTmFtZSk7XG4gICAgICAgIGlmICghdHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGUgaGFzIG5vIHByb3BlcnR5IFwiICsgbWV0aG9kTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodHR5cGUgaW5zdGFuY2VvZiB0eXBlc18xLlRGdW5jKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvcGVydHkgXCIgKyBtZXRob2ROYW1lICsgXCIgaXMgbm90IGEgbWV0aG9kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0dHlwZTtcbiAgICB9O1xuICAgIHJldHVybiBDaGVja2VyO1xufSgpKTtcbmV4cG9ydHMuQ2hlY2tlciA9IENoZWNrZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ts-interface-checker/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ts-interface-checker/dist/types.js":
/*!*********************************************************!*\
  !*** ./node_modules/ts-interface-checker/dist/types.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * This module defines nodes used to define types and validations for objects and interfaces.\n */\n// tslint:disable:no-shadowed-variable prefer-for-of\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.basicTypes = exports.BasicType = exports.TParamList = exports.TParam = exports.param = exports.TFunc = exports.func = exports.TProp = exports.TOptional = exports.opt = exports.TIface = exports.iface = exports.TEnumLiteral = exports.enumlit = exports.TEnumType = exports.enumtype = exports.TIntersection = exports.intersection = exports.TUnion = exports.union = exports.TTuple = exports.tuple = exports.TArray = exports.array = exports.TLiteral = exports.lit = exports.TName = exports.name = exports.TType = void 0;\nvar util_1 = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/ts-interface-checker/dist/util.js\");\n/** Node that represents a type. */\nvar TType = /** @class */ (function () {\n    function TType() {\n    }\n    return TType;\n}());\nexports.TType = TType;\n/** Parses a type spec into a TType node. */\nfunction parseSpec(typeSpec) {\n    return typeof typeSpec === \"string\" ? name(typeSpec) : typeSpec;\n}\nfunction getNamedType(suite, name) {\n    var ttype = suite[name];\n    if (!ttype) {\n        throw new Error(\"Unknown type \" + name);\n    }\n    return ttype;\n}\n/**\n * Defines a type name, either built-in, or defined in this suite. It can typically be included in\n * the specs as just a plain string.\n */\nfunction name(value) { return new TName(value); }\nexports.name = name;\nvar TName = /** @class */ (function (_super) {\n    __extends(TName, _super);\n    function TName(name) {\n        var _this = _super.call(this) || this;\n        _this.name = name;\n        _this._failMsg = \"is not a \" + name;\n        return _this;\n    }\n    TName.prototype.getChecker = function (suite, strict, allowedProps) {\n        var _this = this;\n        var ttype = getNamedType(suite, this.name);\n        var checker = ttype.getChecker(suite, strict, allowedProps);\n        if (ttype instanceof BasicType || ttype instanceof TName) {\n            return checker;\n        }\n        // For complex types, add an additional \"is not a <Type>\" message on failure.\n        return function (value, ctx) { return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0); };\n    };\n    return TName;\n}(TType));\nexports.TName = TName;\n/**\n * Defines a literal value, e.g. lit('hello') or lit(123).\n */\nfunction lit(value) { return new TLiteral(value); }\nexports.lit = lit;\nvar TLiteral = /** @class */ (function (_super) {\n    __extends(TLiteral, _super);\n    function TLiteral(value) {\n        var _this = _super.call(this) || this;\n        _this.value = value;\n        _this.name = JSON.stringify(value);\n        _this._failMsg = \"is not \" + _this.name;\n        return _this;\n    }\n    TLiteral.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) { return (value === _this.value) ? true : ctx.fail(null, _this._failMsg, -1); };\n    };\n    return TLiteral;\n}(TType));\nexports.TLiteral = TLiteral;\n/**\n * Defines an array type, e.g. array('number').\n */\nfunction array(typeSpec) { return new TArray(parseSpec(typeSpec)); }\nexports.array = array;\nvar TArray = /** @class */ (function (_super) {\n    __extends(TArray, _super);\n    function TArray(ttype) {\n        var _this = _super.call(this) || this;\n        _this.ttype = ttype;\n        return _this;\n    }\n    TArray.prototype.getChecker = function (suite, strict) {\n        var itemChecker = this.ttype.getChecker(suite, strict);\n        return function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < value.length; i++) {\n                var ok = itemChecker(value[i], ctx);\n                if (!ok) {\n                    return ctx.fail(i, null, 1);\n                }\n            }\n            return true;\n        };\n    };\n    return TArray;\n}(TType));\nexports.TArray = TArray;\n/**\n * Defines a tuple type, e.g. tuple('string', 'number').\n */\nfunction tuple() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TTuple(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.tuple = tuple;\nvar TTuple = /** @class */ (function (_super) {\n    __extends(TTuple, _super);\n    function TTuple(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        return _this;\n    }\n    TTuple.prototype.getChecker = function (suite, strict) {\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });\n        var checker = function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var ok = itemCheckers[i](value[i], ctx);\n                if (!ok) {\n                    return ctx.fail(i, null, 1);\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            return value.length <= itemCheckers.length ? true :\n                ctx.fail(itemCheckers.length, \"is extraneous\", 2);\n        };\n    };\n    return TTuple;\n}(TType));\nexports.TTuple = TTuple;\n/**\n * Defines a union type, e.g. union('number', 'null').\n */\nfunction union() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TUnion(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.union = union;\nvar TUnion = /** @class */ (function (_super) {\n    __extends(TUnion, _super);\n    function TUnion(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        var names = ttypes.map(function (t) { return t instanceof TName || t instanceof TLiteral ? t.name : null; })\n            .filter(function (n) { return n; });\n        var otherTypes = ttypes.length - names.length;\n        if (names.length) {\n            if (otherTypes > 0) {\n                names.push(otherTypes + \" more\");\n            }\n            _this._failMsg = \"is none of \" + names.join(\", \");\n        }\n        else {\n            _this._failMsg = \"is none of \" + otherTypes + \" types\";\n        }\n        return _this;\n    }\n    TUnion.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });\n        return function (value, ctx) {\n            var ur = ctx.unionResolver();\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var ok = itemCheckers[i](value, ur.createContext());\n                if (ok) {\n                    return true;\n                }\n            }\n            ctx.resolveUnion(ur);\n            return ctx.fail(null, _this._failMsg, 0);\n        };\n    };\n    return TUnion;\n}(TType));\nexports.TUnion = TUnion;\n/**\n * Defines an intersection type, e.g. intersection('number', 'null').\n */\nfunction intersection() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TIntersection(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.intersection = intersection;\nvar TIntersection = /** @class */ (function (_super) {\n    __extends(TIntersection, _super);\n    function TIntersection(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        return _this;\n    }\n    TIntersection.prototype.getChecker = function (suite, strict) {\n        var allowedProps = new Set();\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict, allowedProps); });\n        return function (value, ctx) {\n            var ok = itemCheckers.every(function (checker) { return checker(value, ctx); });\n            if (ok) {\n                return true;\n            }\n            return ctx.fail(null, null, 0);\n        };\n    };\n    return TIntersection;\n}(TType));\nexports.TIntersection = TIntersection;\n/**\n * Defines an enum type, e.g. enum({'A': 1, 'B': 2}).\n */\nfunction enumtype(values) {\n    return new TEnumType(values);\n}\nexports.enumtype = enumtype;\nvar TEnumType = /** @class */ (function (_super) {\n    __extends(TEnumType, _super);\n    function TEnumType(members) {\n        var _this = _super.call(this) || this;\n        _this.members = members;\n        _this.validValues = new Set();\n        _this._failMsg = \"is not a valid enum value\";\n        _this.validValues = new Set(Object.keys(members).map(function (name) { return members[name]; }));\n        return _this;\n    }\n    TEnumType.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) {\n            return (_this.validValues.has(value) ? true : ctx.fail(null, _this._failMsg, 0));\n        };\n    };\n    return TEnumType;\n}(TType));\nexports.TEnumType = TEnumType;\n/**\n * Defines a literal enum value, such as Direction.Up, specified as enumlit(\"Direction\", \"Up\").\n */\nfunction enumlit(name, prop) {\n    return new TEnumLiteral(name, prop);\n}\nexports.enumlit = enumlit;\nvar TEnumLiteral = /** @class */ (function (_super) {\n    __extends(TEnumLiteral, _super);\n    function TEnumLiteral(enumName, prop) {\n        var _this = _super.call(this) || this;\n        _this.enumName = enumName;\n        _this.prop = prop;\n        _this._failMsg = \"is not \" + enumName + \".\" + prop;\n        return _this;\n    }\n    TEnumLiteral.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var ttype = getNamedType(suite, this.enumName);\n        if (!(ttype instanceof TEnumType)) {\n            throw new Error(\"Type \" + this.enumName + \" used in enumlit is not an enum type\");\n        }\n        var val = ttype.members[this.prop];\n        if (!ttype.members.hasOwnProperty(this.prop)) {\n            throw new Error(\"Unknown value \" + this.enumName + \".\" + this.prop + \" used in enumlit\");\n        }\n        return function (value, ctx) { return (value === val) ? true : ctx.fail(null, _this._failMsg, -1); };\n    };\n    return TEnumLiteral;\n}(TType));\nexports.TEnumLiteral = TEnumLiteral;\nfunction makeIfaceProps(props) {\n    return Object.keys(props).map(function (name) { return makeIfaceProp(name, props[name]); });\n}\nfunction makeIfaceProp(name, prop) {\n    return prop instanceof TOptional ?\n        new TProp(name, prop.ttype, true) :\n        new TProp(name, parseSpec(prop), false);\n}\n/**\n * Defines an interface. The first argument is an array of interfaces that it extends, and the\n * second is an array of properties.\n */\nfunction iface(bases, props) {\n    return new TIface(bases, makeIfaceProps(props));\n}\nexports.iface = iface;\nvar TIface = /** @class */ (function (_super) {\n    __extends(TIface, _super);\n    function TIface(bases, props) {\n        var _this = _super.call(this) || this;\n        _this.bases = bases;\n        _this.props = props;\n        _this.propSet = new Set(props.map(function (p) { return p.name; }));\n        return _this;\n    }\n    TIface.prototype.getChecker = function (suite, strict, allowedProps) {\n        var _this = this;\n        var baseCheckers = this.bases.map(function (b) { return getNamedType(suite, b).getChecker(suite, strict); });\n        var propCheckers = this.props.map(function (prop) { return prop.ttype.getChecker(suite, strict); });\n        var testCtx = new util_1.NoopContext();\n        // Consider a prop required if it's not optional AND does not allow for undefined as a value.\n        var isPropRequired = this.props.map(function (prop, i) {\n            return !prop.isOpt && !propCheckers[i](undefined, testCtx);\n        });\n        var checker = function (value, ctx) {\n            if (typeof value !== \"object\" || value === null) {\n                return ctx.fail(null, \"is not an object\", 0);\n            }\n            for (var i = 0; i < baseCheckers.length; i++) {\n                if (!baseCheckers[i](value, ctx)) {\n                    return false;\n                }\n            }\n            for (var i = 0; i < propCheckers.length; i++) {\n                var name_1 = _this.props[i].name;\n                var v = value[name_1];\n                if (v === undefined) {\n                    if (isPropRequired[i]) {\n                        return ctx.fail(name_1, \"is missing\", 1);\n                    }\n                }\n                else {\n                    var ok = propCheckers[i](v, ctx);\n                    if (!ok) {\n                        return ctx.fail(name_1, null, 1);\n                    }\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        var propSet = this.propSet;\n        if (allowedProps) {\n            this.propSet.forEach(function (prop) { return allowedProps.add(prop); });\n            propSet = allowedProps;\n        }\n        // In strict mode, check also for unknown enumerable properties.\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            for (var prop in value) {\n                if (!propSet.has(prop)) {\n                    return ctx.fail(prop, \"is extraneous\", 2);\n                }\n            }\n            return true;\n        };\n    };\n    return TIface;\n}(TType));\nexports.TIface = TIface;\n/**\n * Defines an optional property on an interface.\n */\nfunction opt(typeSpec) { return new TOptional(parseSpec(typeSpec)); }\nexports.opt = opt;\nvar TOptional = /** @class */ (function (_super) {\n    __extends(TOptional, _super);\n    function TOptional(ttype) {\n        var _this = _super.call(this) || this;\n        _this.ttype = ttype;\n        return _this;\n    }\n    TOptional.prototype.getChecker = function (suite, strict) {\n        var itemChecker = this.ttype.getChecker(suite, strict);\n        return function (value, ctx) {\n            return value === undefined || itemChecker(value, ctx);\n        };\n    };\n    return TOptional;\n}(TType));\nexports.TOptional = TOptional;\n/**\n * Defines a property in an interface.\n */\nvar TProp = /** @class */ (function () {\n    function TProp(name, ttype, isOpt) {\n        this.name = name;\n        this.ttype = ttype;\n        this.isOpt = isOpt;\n    }\n    return TProp;\n}());\nexports.TProp = TProp;\n/**\n * Defines a function. The first argument declares the function's return type, the rest declare\n * its parameters.\n */\nfunction func(resultSpec) {\n    var params = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        params[_i - 1] = arguments[_i];\n    }\n    return new TFunc(new TParamList(params), parseSpec(resultSpec));\n}\nexports.func = func;\nvar TFunc = /** @class */ (function (_super) {\n    __extends(TFunc, _super);\n    function TFunc(paramList, result) {\n        var _this = _super.call(this) || this;\n        _this.paramList = paramList;\n        _this.result = result;\n        return _this;\n    }\n    TFunc.prototype.getChecker = function (suite, strict) {\n        return function (value, ctx) {\n            return typeof value === \"function\" ? true : ctx.fail(null, \"is not a function\", 0);\n        };\n    };\n    return TFunc;\n}(TType));\nexports.TFunc = TFunc;\n/**\n * Defines a function parameter.\n */\nfunction param(name, typeSpec, isOpt) {\n    return new TParam(name, parseSpec(typeSpec), Boolean(isOpt));\n}\nexports.param = param;\nvar TParam = /** @class */ (function () {\n    function TParam(name, ttype, isOpt) {\n        this.name = name;\n        this.ttype = ttype;\n        this.isOpt = isOpt;\n    }\n    return TParam;\n}());\nexports.TParam = TParam;\n/**\n * Defines a function parameter list.\n */\nvar TParamList = /** @class */ (function (_super) {\n    __extends(TParamList, _super);\n    function TParamList(params) {\n        var _this = _super.call(this) || this;\n        _this.params = params;\n        return _this;\n    }\n    TParamList.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var itemCheckers = this.params.map(function (t) { return t.ttype.getChecker(suite, strict); });\n        var testCtx = new util_1.NoopContext();\n        var isParamRequired = this.params.map(function (param, i) {\n            return !param.isOpt && !itemCheckers[i](undefined, testCtx);\n        });\n        var checker = function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var p = _this.params[i];\n                if (value[i] === undefined) {\n                    if (isParamRequired[i]) {\n                        return ctx.fail(p.name, \"is missing\", 1);\n                    }\n                }\n                else {\n                    var ok = itemCheckers[i](value[i], ctx);\n                    if (!ok) {\n                        return ctx.fail(p.name, null, 1);\n                    }\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            return value.length <= itemCheckers.length ? true :\n                ctx.fail(itemCheckers.length, \"is extraneous\", 2);\n        };\n    };\n    return TParamList;\n}(TType));\nexports.TParamList = TParamList;\n/**\n * Single TType implementation for all basic built-in types.\n */\nvar BasicType = /** @class */ (function (_super) {\n    __extends(BasicType, _super);\n    function BasicType(validator, message) {\n        var _this = _super.call(this) || this;\n        _this.validator = validator;\n        _this.message = message;\n        return _this;\n    }\n    BasicType.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) { return _this.validator(value) ? true : ctx.fail(null, _this.message, 0); };\n    };\n    return BasicType;\n}(TType));\nexports.BasicType = BasicType;\n/**\n * Defines the suite of basic types.\n */\nexports.basicTypes = {\n    any: new BasicType(function (v) { return true; }, \"is invalid\"),\n    number: new BasicType(function (v) { return (typeof v === \"number\"); }, \"is not a number\"),\n    object: new BasicType(function (v) { return (typeof v === \"object\" && v); }, \"is not an object\"),\n    boolean: new BasicType(function (v) { return (typeof v === \"boolean\"); }, \"is not a boolean\"),\n    string: new BasicType(function (v) { return (typeof v === \"string\"); }, \"is not a string\"),\n    symbol: new BasicType(function (v) { return (typeof v === \"symbol\"); }, \"is not a symbol\"),\n    void: new BasicType(function (v) { return (v == null); }, \"is not void\"),\n    undefined: new BasicType(function (v) { return (v === undefined); }, \"is not undefined\"),\n    null: new BasicType(function (v) { return (v === null); }, \"is not null\"),\n    never: new BasicType(function (v) { return false; }, \"is unexpected\"),\n    Date: new BasicType(getIsNativeChecker(\"[object Date]\"), \"is not a Date\"),\n    RegExp: new BasicType(getIsNativeChecker(\"[object RegExp]\"), \"is not a RegExp\"),\n};\n// This approach for checking native object types mirrors that of lodash. Its advantage over\n// `isinstance` is that it can still return true for native objects created in different JS\n// execution environments.\nvar nativeToString = Object.prototype.toString;\nfunction getIsNativeChecker(tag) {\n    return function (v) { return typeof v === \"object\" && v && nativeToString.call(v) === tag; };\n}\nif (typeof Buffer !== \"undefined\") {\n    exports.basicTypes.Buffer = new BasicType(function (v) { return Buffer.isBuffer(v); }, \"is not a Buffer\");\n}\nvar _loop_1 = function (array_1) {\n    exports.basicTypes[array_1.name] = new BasicType(function (v) { return (v instanceof array_1); }, \"is not a \" + array_1.name);\n};\n// Support typed arrays of various flavors\nfor (var _i = 0, _a = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]; _i < _a.length; _i++) {\n    var array_1 = _a[_i];\n    _loop_1(array_1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHMtaW50ZXJmYWNlLWNoZWNrZXIvZGlzdC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLGFBQWEsR0FBRyxpQkFBaUIsR0FBRyxXQUFXLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxvQkFBb0IsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVyxHQUFHLGFBQWEsR0FBRyxZQUFZLEdBQUcsYUFBYTtBQUNoZ0IsYUFBYSxtQkFBTyxDQUFDLHNFQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLENBQUM7QUFDRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxxQ0FBcUM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0Esa0RBQWtELHNCQUFzQjtBQUN4RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFFQUFxRTtBQUNuSCxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHFDQUFxQztBQUMvRjtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG1EQUFtRDtBQUM3RztBQUNBLDZEQUE2RCw2QkFBNkI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsdUJBQXVCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0JBQW9CO0FBQ3BCO0FBQ0Esb0RBQW9ELDBDQUEwQztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDBEQUEwRDtBQUNuSCw0REFBNEQsOENBQThDO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdDQUFnQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwyQ0FBMkM7QUFDckc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixzQ0FBc0MsY0FBYztBQUNwRCx5Q0FBeUMsaUNBQWlDO0FBQzFFLHlDQUF5QyxzQ0FBc0M7QUFDL0UsMENBQTBDLGtDQUFrQztBQUM1RSx5Q0FBeUMsaUNBQWlDO0FBQzFFLHlDQUF5QyxpQ0FBaUM7QUFDMUUsdUNBQXVDLHFCQUFxQjtBQUM1RCw0Q0FBNEMsMkJBQTJCO0FBQ3ZFLHVDQUF1QyxzQkFBc0I7QUFDN0Qsd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsSUFBSSx5QkFBeUIsZ0NBQWdDLDRCQUE0QjtBQUN6RjtBQUNBO0FBQ0Esb0VBQW9FLGdDQUFnQztBQUNwRztBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsZ0JBQWdCO0FBQ3ZGO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWxpYnJhcnktZG9jcy8uL25vZGVfbW9kdWxlcy90cy1pbnRlcmZhY2UtY2hlY2tlci9kaXN0L3R5cGVzLmpzP2FkNWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFRoaXMgbW9kdWxlIGRlZmluZXMgbm9kZXMgdXNlZCB0byBkZWZpbmUgdHlwZXMgYW5kIHZhbGlkYXRpb25zIGZvciBvYmplY3RzIGFuZCBpbnRlcmZhY2VzLlxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1zaGFkb3dlZC12YXJpYWJsZSBwcmVmZXItZm9yLW9mXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFzaWNUeXBlcyA9IGV4cG9ydHMuQmFzaWNUeXBlID0gZXhwb3J0cy5UUGFyYW1MaXN0ID0gZXhwb3J0cy5UUGFyYW0gPSBleHBvcnRzLnBhcmFtID0gZXhwb3J0cy5URnVuYyA9IGV4cG9ydHMuZnVuYyA9IGV4cG9ydHMuVFByb3AgPSBleHBvcnRzLlRPcHRpb25hbCA9IGV4cG9ydHMub3B0ID0gZXhwb3J0cy5USWZhY2UgPSBleHBvcnRzLmlmYWNlID0gZXhwb3J0cy5URW51bUxpdGVyYWwgPSBleHBvcnRzLmVudW1saXQgPSBleHBvcnRzLlRFbnVtVHlwZSA9IGV4cG9ydHMuZW51bXR5cGUgPSBleHBvcnRzLlRJbnRlcnNlY3Rpb24gPSBleHBvcnRzLmludGVyc2VjdGlvbiA9IGV4cG9ydHMuVFVuaW9uID0gZXhwb3J0cy51bmlvbiA9IGV4cG9ydHMuVFR1cGxlID0gZXhwb3J0cy50dXBsZSA9IGV4cG9ydHMuVEFycmF5ID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMuVExpdGVyYWwgPSBleHBvcnRzLmxpdCA9IGV4cG9ydHMuVE5hbWUgPSBleHBvcnRzLm5hbWUgPSBleHBvcnRzLlRUeXBlID0gdm9pZCAwO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG4vKiogTm9kZSB0aGF0IHJlcHJlc2VudHMgYSB0eXBlLiAqL1xudmFyIFRUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRUeXBlKCkge1xuICAgIH1cbiAgICByZXR1cm4gVFR5cGU7XG59KCkpO1xuZXhwb3J0cy5UVHlwZSA9IFRUeXBlO1xuLyoqIFBhcnNlcyBhIHR5cGUgc3BlYyBpbnRvIGEgVFR5cGUgbm9kZS4gKi9cbmZ1bmN0aW9uIHBhcnNlU3BlYyh0eXBlU3BlYykge1xuICAgIHJldHVybiB0eXBlb2YgdHlwZVNwZWMgPT09IFwic3RyaW5nXCIgPyBuYW1lKHR5cGVTcGVjKSA6IHR5cGVTcGVjO1xufVxuZnVuY3Rpb24gZ2V0TmFtZWRUeXBlKHN1aXRlLCBuYW1lKSB7XG4gICAgdmFyIHR0eXBlID0gc3VpdGVbbmFtZV07XG4gICAgaWYgKCF0dHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIgKyBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHR0eXBlO1xufVxuLyoqXG4gKiBEZWZpbmVzIGEgdHlwZSBuYW1lLCBlaXRoZXIgYnVpbHQtaW4sIG9yIGRlZmluZWQgaW4gdGhpcyBzdWl0ZS4gSXQgY2FuIHR5cGljYWxseSBiZSBpbmNsdWRlZCBpblxuICogdGhlIHNwZWNzIGFzIGp1c3QgYSBwbGFpbiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG5hbWUodmFsdWUpIHsgcmV0dXJuIG5ldyBUTmFtZSh2YWx1ZSk7IH1cbmV4cG9ydHMubmFtZSA9IG5hbWU7XG52YXIgVE5hbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFROYW1lLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFROYW1lKG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLl9mYWlsTXNnID0gXCJpcyBub3QgYSBcIiArIG5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVE5hbWUucHJvdG90eXBlLmdldENoZWNrZXIgPSBmdW5jdGlvbiAoc3VpdGUsIHN0cmljdCwgYWxsb3dlZFByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0dHlwZSA9IGdldE5hbWVkVHlwZShzdWl0ZSwgdGhpcy5uYW1lKTtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSB0dHlwZS5nZXRDaGVja2VyKHN1aXRlLCBzdHJpY3QsIGFsbG93ZWRQcm9wcyk7XG4gICAgICAgIGlmICh0dHlwZSBpbnN0YW5jZW9mIEJhc2ljVHlwZSB8fCB0dHlwZSBpbnN0YW5jZW9mIFROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgY29tcGxleCB0eXBlcywgYWRkIGFuIGFkZGl0aW9uYWwgXCJpcyBub3QgYSA8VHlwZT5cIiBtZXNzYWdlIG9uIGZhaWx1cmUuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGN0eCkgeyByZXR1cm4gY2hlY2tlcih2YWx1ZSwgY3R4KSA/IHRydWUgOiBjdHguZmFpbChudWxsLCBfdGhpcy5fZmFpbE1zZywgMCk7IH07XG4gICAgfTtcbiAgICByZXR1cm4gVE5hbWU7XG59KFRUeXBlKSk7XG5leHBvcnRzLlROYW1lID0gVE5hbWU7XG4vKipcbiAqIERlZmluZXMgYSBsaXRlcmFsIHZhbHVlLCBlLmcuIGxpdCgnaGVsbG8nKSBvciBsaXQoMTIzKS5cbiAqL1xuZnVuY3Rpb24gbGl0KHZhbHVlKSB7IHJldHVybiBuZXcgVExpdGVyYWwodmFsdWUpOyB9XG5leHBvcnRzLmxpdCA9IGxpdDtcbnZhciBUTGl0ZXJhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVExpdGVyYWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVExpdGVyYWwodmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgX3RoaXMubmFtZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgX3RoaXMuX2ZhaWxNc2cgPSBcImlzIG5vdCBcIiArIF90aGlzLm5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVExpdGVyYWwucHJvdG90eXBlLmdldENoZWNrZXIgPSBmdW5jdGlvbiAoc3VpdGUsIHN0cmljdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBjdHgpIHsgcmV0dXJuICh2YWx1ZSA9PT0gX3RoaXMudmFsdWUpID8gdHJ1ZSA6IGN0eC5mYWlsKG51bGwsIF90aGlzLl9mYWlsTXNnLCAtMSk7IH07XG4gICAgfTtcbiAgICByZXR1cm4gVExpdGVyYWw7XG59KFRUeXBlKSk7XG5leHBvcnRzLlRMaXRlcmFsID0gVExpdGVyYWw7XG4vKipcbiAqIERlZmluZXMgYW4gYXJyYXkgdHlwZSwgZS5nLiBhcnJheSgnbnVtYmVyJykuXG4gKi9cbmZ1bmN0aW9uIGFycmF5KHR5cGVTcGVjKSB7IHJldHVybiBuZXcgVEFycmF5KHBhcnNlU3BlYyh0eXBlU3BlYykpOyB9XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG52YXIgVEFycmF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUQXJyYXksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVEFycmF5KHR0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR0eXBlID0gdHR5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVEFycmF5LnByb3RvdHlwZS5nZXRDaGVja2VyID0gZnVuY3Rpb24gKHN1aXRlLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGl0ZW1DaGVja2VyID0gdGhpcy50dHlwZS5nZXRDaGVja2VyKHN1aXRlLCBzdHJpY3QpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LmZhaWwobnVsbCwgXCJpcyBub3QgYW4gYXJyYXlcIiwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9rID0gaXRlbUNoZWNrZXIodmFsdWVbaV0sIGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LmZhaWwoaSwgbnVsbCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVEFycmF5O1xufShUVHlwZSkpO1xuZXhwb3J0cy5UQXJyYXkgPSBUQXJyYXk7XG4vKipcbiAqIERlZmluZXMgYSB0dXBsZSB0eXBlLCBlLmcuIHR1cGxlKCdzdHJpbmcnLCAnbnVtYmVyJykuXG4gKi9cbmZ1bmN0aW9uIHR1cGxlKCkge1xuICAgIHZhciB0eXBlU3BlYyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHR5cGVTcGVjW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVFR1cGxlKHR5cGVTcGVjLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gcGFyc2VTcGVjKHQpOyB9KSk7XG59XG5leHBvcnRzLnR1cGxlID0gdHVwbGU7XG52YXIgVFR1cGxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUVHVwbGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVFR1cGxlKHR0eXBlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50dHlwZXMgPSB0dHlwZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVFR1cGxlLnByb3RvdHlwZS5nZXRDaGVja2VyID0gZnVuY3Rpb24gKHN1aXRlLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGl0ZW1DaGVja2VycyA9IHRoaXMudHR5cGVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5nZXRDaGVja2VyKHN1aXRlLCBzdHJpY3QpOyB9KTtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBmdW5jdGlvbiAodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHguZmFpbChudWxsLCBcImlzIG5vdCBhbiBhcnJheVwiLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9rID0gaXRlbUNoZWNrZXJzW2ldKHZhbHVlW2ldLCBjdHgpO1xuICAgICAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5mYWlsKGksIG51bGwsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXN0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrZXIodmFsdWUsIGN0eCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoIDw9IGl0ZW1DaGVja2Vycy5sZW5ndGggPyB0cnVlIDpcbiAgICAgICAgICAgICAgICBjdHguZmFpbChpdGVtQ2hlY2tlcnMubGVuZ3RoLCBcImlzIGV4dHJhbmVvdXNcIiwgMik7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVFR1cGxlO1xufShUVHlwZSkpO1xuZXhwb3J0cy5UVHVwbGUgPSBUVHVwbGU7XG4vKipcbiAqIERlZmluZXMgYSB1bmlvbiB0eXBlLCBlLmcuIHVuaW9uKCdudW1iZXInLCAnbnVsbCcpLlxuICovXG5mdW5jdGlvbiB1bmlvbigpIHtcbiAgICB2YXIgdHlwZVNwZWMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0eXBlU3BlY1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRVbmlvbih0eXBlU3BlYy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHBhcnNlU3BlYyh0KTsgfSkpO1xufVxuZXhwb3J0cy51bmlvbiA9IHVuaW9uO1xudmFyIFRVbmlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVFVuaW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRVbmlvbih0dHlwZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHR5cGVzID0gdHR5cGVzO1xuICAgICAgICB2YXIgbmFtZXMgPSB0dHlwZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IGluc3RhbmNlb2YgVE5hbWUgfHwgdCBpbnN0YW5jZW9mIFRMaXRlcmFsID8gdC5uYW1lIDogbnVsbDsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG47IH0pO1xuICAgICAgICB2YXIgb3RoZXJUeXBlcyA9IHR0eXBlcy5sZW5ndGggLSBuYW1lcy5sZW5ndGg7XG4gICAgICAgIGlmIChuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChvdGhlclR5cGVzID4gMCkge1xuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2gob3RoZXJUeXBlcyArIFwiIG1vcmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fZmFpbE1zZyA9IFwiaXMgbm9uZSBvZiBcIiArIG5hbWVzLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLl9mYWlsTXNnID0gXCJpcyBub25lIG9mIFwiICsgb3RoZXJUeXBlcyArIFwiIHR5cGVzXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUVW5pb24ucHJvdG90eXBlLmdldENoZWNrZXIgPSBmdW5jdGlvbiAoc3VpdGUsIHN0cmljdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaXRlbUNoZWNrZXJzID0gdGhpcy50dHlwZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmdldENoZWNrZXIoc3VpdGUsIHN0cmljdCk7IH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHZhciB1ciA9IGN0eC51bmlvblJlc29sdmVyKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1DaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvayA9IGl0ZW1DaGVja2Vyc1tpXSh2YWx1ZSwgdXIuY3JlYXRlQ29udGV4dCgpKTtcbiAgICAgICAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnJlc29sdmVVbmlvbih1cik7XG4gICAgICAgICAgICByZXR1cm4gY3R4LmZhaWwobnVsbCwgX3RoaXMuX2ZhaWxNc2csIDApO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRVbmlvbjtcbn0oVFR5cGUpKTtcbmV4cG9ydHMuVFVuaW9uID0gVFVuaW9uO1xuLyoqXG4gKiBEZWZpbmVzIGFuIGludGVyc2VjdGlvbiB0eXBlLCBlLmcuIGludGVyc2VjdGlvbignbnVtYmVyJywgJ251bGwnKS5cbiAqL1xuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKCkge1xuICAgIHZhciB0eXBlU3BlYyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHR5cGVTcGVjW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVEludGVyc2VjdGlvbih0eXBlU3BlYy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHBhcnNlU3BlYyh0KTsgfSkpO1xufVxuZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG52YXIgVEludGVyc2VjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVEludGVyc2VjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUSW50ZXJzZWN0aW9uKHR0eXBlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50dHlwZXMgPSB0dHlwZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVEludGVyc2VjdGlvbi5wcm90b3R5cGUuZ2V0Q2hlY2tlciA9IGZ1bmN0aW9uIChzdWl0ZSwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBhbGxvd2VkUHJvcHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciBpdGVtQ2hlY2tlcnMgPSB0aGlzLnR0eXBlcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZ2V0Q2hlY2tlcihzdWl0ZSwgc3RyaWN0LCBhbGxvd2VkUHJvcHMpOyB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICB2YXIgb2sgPSBpdGVtQ2hlY2tlcnMuZXZlcnkoZnVuY3Rpb24gKGNoZWNrZXIpIHsgcmV0dXJuIGNoZWNrZXIodmFsdWUsIGN0eCk7IH0pO1xuICAgICAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3R4LmZhaWwobnVsbCwgbnVsbCwgMCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVEludGVyc2VjdGlvbjtcbn0oVFR5cGUpKTtcbmV4cG9ydHMuVEludGVyc2VjdGlvbiA9IFRJbnRlcnNlY3Rpb247XG4vKipcbiAqIERlZmluZXMgYW4gZW51bSB0eXBlLCBlLmcuIGVudW0oeydBJzogMSwgJ0InOiAyfSkuXG4gKi9cbmZ1bmN0aW9uIGVudW10eXBlKHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgVEVudW1UeXBlKHZhbHVlcyk7XG59XG5leHBvcnRzLmVudW10eXBlID0gZW51bXR5cGU7XG52YXIgVEVudW1UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhURW51bVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVEVudW1UeXBlKG1lbWJlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWVtYmVycyA9IG1lbWJlcnM7XG4gICAgICAgIF90aGlzLnZhbGlkVmFsdWVzID0gbmV3IFNldCgpO1xuICAgICAgICBfdGhpcy5fZmFpbE1zZyA9IFwiaXMgbm90IGEgdmFsaWQgZW51bSB2YWx1ZVwiO1xuICAgICAgICBfdGhpcy52YWxpZFZhbHVlcyA9IG5ldyBTZXQoT2JqZWN0LmtleXMobWVtYmVycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtZW1iZXJzW25hbWVdOyB9KSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVEVudW1UeXBlLnByb3RvdHlwZS5nZXRDaGVja2VyID0gZnVuY3Rpb24gKHN1aXRlLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gKF90aGlzLnZhbGlkVmFsdWVzLmhhcyh2YWx1ZSkgPyB0cnVlIDogY3R4LmZhaWwobnVsbCwgX3RoaXMuX2ZhaWxNc2csIDApKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBURW51bVR5cGU7XG59KFRUeXBlKSk7XG5leHBvcnRzLlRFbnVtVHlwZSA9IFRFbnVtVHlwZTtcbi8qKlxuICogRGVmaW5lcyBhIGxpdGVyYWwgZW51bSB2YWx1ZSwgc3VjaCBhcyBEaXJlY3Rpb24uVXAsIHNwZWNpZmllZCBhcyBlbnVtbGl0KFwiRGlyZWN0aW9uXCIsIFwiVXBcIikuXG4gKi9cbmZ1bmN0aW9uIGVudW1saXQobmFtZSwgcHJvcCkge1xuICAgIHJldHVybiBuZXcgVEVudW1MaXRlcmFsKG5hbWUsIHByb3ApO1xufVxuZXhwb3J0cy5lbnVtbGl0ID0gZW51bWxpdDtcbnZhciBURW51bUxpdGVyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRFbnVtTGl0ZXJhbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBURW51bUxpdGVyYWwoZW51bU5hbWUsIHByb3ApIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZW51bU5hbWUgPSBlbnVtTmFtZTtcbiAgICAgICAgX3RoaXMucHJvcCA9IHByb3A7XG4gICAgICAgIF90aGlzLl9mYWlsTXNnID0gXCJpcyBub3QgXCIgKyBlbnVtTmFtZSArIFwiLlwiICsgcHJvcDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBURW51bUxpdGVyYWwucHJvdG90eXBlLmdldENoZWNrZXIgPSBmdW5jdGlvbiAoc3VpdGUsIHN0cmljdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdHR5cGUgPSBnZXROYW1lZFR5cGUoc3VpdGUsIHRoaXMuZW51bU5hbWUpO1xuICAgICAgICBpZiAoISh0dHlwZSBpbnN0YW5jZW9mIFRFbnVtVHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGUgXCIgKyB0aGlzLmVudW1OYW1lICsgXCIgdXNlZCBpbiBlbnVtbGl0IGlzIG5vdCBhbiBlbnVtIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbCA9IHR0eXBlLm1lbWJlcnNbdGhpcy5wcm9wXTtcbiAgICAgICAgaWYgKCF0dHlwZS5tZW1iZXJzLmhhc093blByb3BlcnR5KHRoaXMucHJvcCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdmFsdWUgXCIgKyB0aGlzLmVudW1OYW1lICsgXCIuXCIgKyB0aGlzLnByb3AgKyBcIiB1c2VkIGluIGVudW1saXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgY3R4KSB7IHJldHVybiAodmFsdWUgPT09IHZhbCkgPyB0cnVlIDogY3R4LmZhaWwobnVsbCwgX3RoaXMuX2ZhaWxNc2csIC0xKTsgfTtcbiAgICB9O1xuICAgIHJldHVybiBURW51bUxpdGVyYWw7XG59KFRUeXBlKSk7XG5leHBvcnRzLlRFbnVtTGl0ZXJhbCA9IFRFbnVtTGl0ZXJhbDtcbmZ1bmN0aW9uIG1ha2VJZmFjZVByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHByb3BzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1ha2VJZmFjZVByb3AobmFtZSwgcHJvcHNbbmFtZV0pOyB9KTtcbn1cbmZ1bmN0aW9uIG1ha2VJZmFjZVByb3AobmFtZSwgcHJvcCkge1xuICAgIHJldHVybiBwcm9wIGluc3RhbmNlb2YgVE9wdGlvbmFsID9cbiAgICAgICAgbmV3IFRQcm9wKG5hbWUsIHByb3AudHR5cGUsIHRydWUpIDpcbiAgICAgICAgbmV3IFRQcm9wKG5hbWUsIHBhcnNlU3BlYyhwcm9wKSwgZmFsc2UpO1xufVxuLyoqXG4gKiBEZWZpbmVzIGFuIGludGVyZmFjZS4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIGFycmF5IG9mIGludGVyZmFjZXMgdGhhdCBpdCBleHRlbmRzLCBhbmQgdGhlXG4gKiBzZWNvbmQgaXMgYW4gYXJyYXkgb2YgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gaWZhY2UoYmFzZXMsIHByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBUSWZhY2UoYmFzZXMsIG1ha2VJZmFjZVByb3BzKHByb3BzKSk7XG59XG5leHBvcnRzLmlmYWNlID0gaWZhY2U7XG52YXIgVElmYWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUSWZhY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVElmYWNlKGJhc2VzLCBwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5iYXNlcyA9IGJhc2VzO1xuICAgICAgICBfdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICBfdGhpcy5wcm9wU2V0ID0gbmV3IFNldChwcm9wcy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAubmFtZTsgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRJZmFjZS5wcm90b3R5cGUuZ2V0Q2hlY2tlciA9IGZ1bmN0aW9uIChzdWl0ZSwgc3RyaWN0LCBhbGxvd2VkUHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGJhc2VDaGVja2VycyA9IHRoaXMuYmFzZXMubWFwKGZ1bmN0aW9uIChiKSB7IHJldHVybiBnZXROYW1lZFR5cGUoc3VpdGUsIGIpLmdldENoZWNrZXIoc3VpdGUsIHN0cmljdCk7IH0pO1xuICAgICAgICB2YXIgcHJvcENoZWNrZXJzID0gdGhpcy5wcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHByb3AudHR5cGUuZ2V0Q2hlY2tlcihzdWl0ZSwgc3RyaWN0KTsgfSk7XG4gICAgICAgIHZhciB0ZXN0Q3R4ID0gbmV3IHV0aWxfMS5Ob29wQ29udGV4dCgpO1xuICAgICAgICAvLyBDb25zaWRlciBhIHByb3AgcmVxdWlyZWQgaWYgaXQncyBub3Qgb3B0aW9uYWwgQU5EIGRvZXMgbm90IGFsbG93IGZvciB1bmRlZmluZWQgYXMgYSB2YWx1ZS5cbiAgICAgICAgdmFyIGlzUHJvcFJlcXVpcmVkID0gdGhpcy5wcm9wcy5tYXAoZnVuY3Rpb24gKHByb3AsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiAhcHJvcC5pc09wdCAmJiAhcHJvcENoZWNrZXJzW2ldKHVuZGVmaW5lZCwgdGVzdEN0eCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2hlY2tlciA9IGZ1bmN0aW9uICh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5mYWlsKG51bGwsIFwiaXMgbm90IGFuIG9iamVjdFwiLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlQ2hlY2tlcnNbaV0odmFsdWUsIGN0eCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcENoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IF90aGlzLnByb3BzW2ldLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB2YWx1ZVtuYW1lXzFdO1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvcFJlcXVpcmVkW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LmZhaWwobmFtZV8xLCBcImlzIG1pc3NpbmdcIiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvayA9IHByb3BDaGVja2Vyc1tpXSh2LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LmZhaWwobmFtZV8xLCBudWxsLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXN0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrZXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BTZXQgPSB0aGlzLnByb3BTZXQ7XG4gICAgICAgIGlmIChhbGxvd2VkUHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcFNldC5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBhbGxvd2VkUHJvcHMuYWRkKHByb3ApOyB9KTtcbiAgICAgICAgICAgIHByb3BTZXQgPSBhbGxvd2VkUHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gc3RyaWN0IG1vZGUsIGNoZWNrIGFsc28gZm9yIHVua25vd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tlcih2YWx1ZSwgY3R4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BTZXQuaGFzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguZmFpbChwcm9wLCBcImlzIGV4dHJhbmVvdXNcIiwgMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVElmYWNlO1xufShUVHlwZSkpO1xuZXhwb3J0cy5USWZhY2UgPSBUSWZhY2U7XG4vKipcbiAqIERlZmluZXMgYW4gb3B0aW9uYWwgcHJvcGVydHkgb24gYW4gaW50ZXJmYWNlLlxuICovXG5mdW5jdGlvbiBvcHQodHlwZVNwZWMpIHsgcmV0dXJuIG5ldyBUT3B0aW9uYWwocGFyc2VTcGVjKHR5cGVTcGVjKSk7IH1cbmV4cG9ydHMub3B0ID0gb3B0O1xudmFyIFRPcHRpb25hbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVE9wdGlvbmFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRPcHRpb25hbCh0dHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50dHlwZSA9IHR0eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRPcHRpb25hbC5wcm90b3R5cGUuZ2V0Q2hlY2tlciA9IGZ1bmN0aW9uIChzdWl0ZSwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpdGVtQ2hlY2tlciA9IHRoaXMudHR5cGUuZ2V0Q2hlY2tlcihzdWl0ZSwgc3RyaWN0KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBpdGVtQ2hlY2tlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUT3B0aW9uYWw7XG59KFRUeXBlKSk7XG5leHBvcnRzLlRPcHRpb25hbCA9IFRPcHRpb25hbDtcbi8qKlxuICogRGVmaW5lcyBhIHByb3BlcnR5IGluIGFuIGludGVyZmFjZS5cbiAqL1xudmFyIFRQcm9wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRQcm9wKG5hbWUsIHR0eXBlLCBpc09wdCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR0eXBlID0gdHR5cGU7XG4gICAgICAgIHRoaXMuaXNPcHQgPSBpc09wdDtcbiAgICB9XG4gICAgcmV0dXJuIFRQcm9wO1xufSgpKTtcbmV4cG9ydHMuVFByb3AgPSBUUHJvcDtcbi8qKlxuICogRGVmaW5lcyBhIGZ1bmN0aW9uLiBUaGUgZmlyc3QgYXJndW1lbnQgZGVjbGFyZXMgdGhlIGZ1bmN0aW9uJ3MgcmV0dXJuIHR5cGUsIHRoZSByZXN0IGRlY2xhcmVcbiAqIGl0cyBwYXJhbWV0ZXJzLlxuICovXG5mdW5jdGlvbiBmdW5jKHJlc3VsdFNwZWMpIHtcbiAgICB2YXIgcGFyYW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgcGFyYW1zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRGdW5jKG5ldyBUUGFyYW1MaXN0KHBhcmFtcyksIHBhcnNlU3BlYyhyZXN1bHRTcGVjKSk7XG59XG5leHBvcnRzLmZ1bmMgPSBmdW5jO1xudmFyIFRGdW5jID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhURnVuYywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBURnVuYyhwYXJhbUxpc3QsIHJlc3VsdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wYXJhbUxpc3QgPSBwYXJhbUxpc3Q7XG4gICAgICAgIF90aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBURnVuYy5wcm90b3R5cGUuZ2V0Q2hlY2tlciA9IGZ1bmN0aW9uIChzdWl0ZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdHJ1ZSA6IGN0eC5mYWlsKG51bGwsIFwiaXMgbm90IGEgZnVuY3Rpb25cIiwgMCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVEZ1bmM7XG59KFRUeXBlKSk7XG5leHBvcnRzLlRGdW5jID0gVEZ1bmM7XG4vKipcbiAqIERlZmluZXMgYSBmdW5jdGlvbiBwYXJhbWV0ZXIuXG4gKi9cbmZ1bmN0aW9uIHBhcmFtKG5hbWUsIHR5cGVTcGVjLCBpc09wdCkge1xuICAgIHJldHVybiBuZXcgVFBhcmFtKG5hbWUsIHBhcnNlU3BlYyh0eXBlU3BlYyksIEJvb2xlYW4oaXNPcHQpKTtcbn1cbmV4cG9ydHMucGFyYW0gPSBwYXJhbTtcbnZhciBUUGFyYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVFBhcmFtKG5hbWUsIHR0eXBlLCBpc09wdCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR0eXBlID0gdHR5cGU7XG4gICAgICAgIHRoaXMuaXNPcHQgPSBpc09wdDtcbiAgICB9XG4gICAgcmV0dXJuIFRQYXJhbTtcbn0oKSk7XG5leHBvcnRzLlRQYXJhbSA9IFRQYXJhbTtcbi8qKlxuICogRGVmaW5lcyBhIGZ1bmN0aW9uIHBhcmFtZXRlciBsaXN0LlxuICovXG52YXIgVFBhcmFtTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVFBhcmFtTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUUGFyYW1MaXN0KHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVFBhcmFtTGlzdC5wcm90b3R5cGUuZ2V0Q2hlY2tlciA9IGZ1bmN0aW9uIChzdWl0ZSwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpdGVtQ2hlY2tlcnMgPSB0aGlzLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQudHR5cGUuZ2V0Q2hlY2tlcihzdWl0ZSwgc3RyaWN0KTsgfSk7XG4gICAgICAgIHZhciB0ZXN0Q3R4ID0gbmV3IHV0aWxfMS5Ob29wQ29udGV4dCgpO1xuICAgICAgICB2YXIgaXNQYXJhbVJlcXVpcmVkID0gdGhpcy5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuICFwYXJhbS5pc09wdCAmJiAhaXRlbUNoZWNrZXJzW2ldKHVuZGVmaW5lZCwgdGVzdEN0eCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2hlY2tlciA9IGZ1bmN0aW9uICh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5mYWlsKG51bGwsIFwiaXMgbm90IGFuIGFycmF5XCIsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IF90aGlzLnBhcmFtc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQYXJhbVJlcXVpcmVkW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LmZhaWwocC5uYW1lLCBcImlzIG1pc3NpbmdcIiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvayA9IGl0ZW1DaGVja2Vyc1tpXSh2YWx1ZVtpXSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5mYWlsKHAubmFtZSwgbnVsbCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgaWYgKCFjaGVja2VyKHZhbHVlLCBjdHgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA8PSBpdGVtQ2hlY2tlcnMubGVuZ3RoID8gdHJ1ZSA6XG4gICAgICAgICAgICAgICAgY3R4LmZhaWwoaXRlbUNoZWNrZXJzLmxlbmd0aCwgXCJpcyBleHRyYW5lb3VzXCIsIDIpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRQYXJhbUxpc3Q7XG59KFRUeXBlKSk7XG5leHBvcnRzLlRQYXJhbUxpc3QgPSBUUGFyYW1MaXN0O1xuLyoqXG4gKiBTaW5nbGUgVFR5cGUgaW1wbGVtZW50YXRpb24gZm9yIGFsbCBiYXNpYyBidWlsdC1pbiB0eXBlcy5cbiAqL1xudmFyIEJhc2ljVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmFzaWNUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhc2ljVHlwZSh2YWxpZGF0b3IsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsaWRhdG9yID0gdmFsaWRhdG9yO1xuICAgICAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBCYXNpY1R5cGUucHJvdG90eXBlLmdldENoZWNrZXIgPSBmdW5jdGlvbiAoc3VpdGUsIHN0cmljdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBjdHgpIHsgcmV0dXJuIF90aGlzLnZhbGlkYXRvcih2YWx1ZSkgPyB0cnVlIDogY3R4LmZhaWwobnVsbCwgX3RoaXMubWVzc2FnZSwgMCk7IH07XG4gICAgfTtcbiAgICByZXR1cm4gQmFzaWNUeXBlO1xufShUVHlwZSkpO1xuZXhwb3J0cy5CYXNpY1R5cGUgPSBCYXNpY1R5cGU7XG4vKipcbiAqIERlZmluZXMgdGhlIHN1aXRlIG9mIGJhc2ljIHR5cGVzLlxuICovXG5leHBvcnRzLmJhc2ljVHlwZXMgPSB7XG4gICAgYW55OiBuZXcgQmFzaWNUeXBlKGZ1bmN0aW9uICh2KSB7IHJldHVybiB0cnVlOyB9LCBcImlzIGludmFsaWRcIiksXG4gICAgbnVtYmVyOiBuZXcgQmFzaWNUeXBlKGZ1bmN0aW9uICh2KSB7IHJldHVybiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpOyB9LCBcImlzIG5vdCBhIG51bWJlclwiKSxcbiAgICBvYmplY3Q6IG5ldyBCYXNpY1R5cGUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2KTsgfSwgXCJpcyBub3QgYW4gb2JqZWN0XCIpLFxuICAgIGJvb2xlYW46IG5ldyBCYXNpY1R5cGUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIpOyB9LCBcImlzIG5vdCBhIGJvb2xlYW5cIiksXG4gICAgc3RyaW5nOiBuZXcgQmFzaWNUeXBlKGZ1bmN0aW9uICh2KSB7IHJldHVybiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpOyB9LCBcImlzIG5vdCBhIHN0cmluZ1wiKSxcbiAgICBzeW1ib2w6IG5ldyBCYXNpY1R5cGUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh0eXBlb2YgdiA9PT0gXCJzeW1ib2xcIik7IH0sIFwiaXMgbm90IGEgc3ltYm9sXCIpLFxuICAgIHZvaWQ6IG5ldyBCYXNpY1R5cGUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh2ID09IG51bGwpOyB9LCBcImlzIG5vdCB2b2lkXCIpLFxuICAgIHVuZGVmaW5lZDogbmV3IEJhc2ljVHlwZShmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgPT09IHVuZGVmaW5lZCk7IH0sIFwiaXMgbm90IHVuZGVmaW5lZFwiKSxcbiAgICBudWxsOiBuZXcgQmFzaWNUeXBlKGZ1bmN0aW9uICh2KSB7IHJldHVybiAodiA9PT0gbnVsbCk7IH0sIFwiaXMgbm90IG51bGxcIiksXG4gICAgbmV2ZXI6IG5ldyBCYXNpY1R5cGUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZhbHNlOyB9LCBcImlzIHVuZXhwZWN0ZWRcIiksXG4gICAgRGF0ZTogbmV3IEJhc2ljVHlwZShnZXRJc05hdGl2ZUNoZWNrZXIoXCJbb2JqZWN0IERhdGVdXCIpLCBcImlzIG5vdCBhIERhdGVcIiksXG4gICAgUmVnRXhwOiBuZXcgQmFzaWNUeXBlKGdldElzTmF0aXZlQ2hlY2tlcihcIltvYmplY3QgUmVnRXhwXVwiKSwgXCJpcyBub3QgYSBSZWdFeHBcIiksXG59O1xuLy8gVGhpcyBhcHByb2FjaCBmb3IgY2hlY2tpbmcgbmF0aXZlIG9iamVjdCB0eXBlcyBtaXJyb3JzIHRoYXQgb2YgbG9kYXNoLiBJdHMgYWR2YW50YWdlIG92ZXJcbi8vIGBpc2luc3RhbmNlYCBpcyB0aGF0IGl0IGNhbiBzdGlsbCByZXR1cm4gdHJ1ZSBmb3IgbmF0aXZlIG9iamVjdHMgY3JlYXRlZCBpbiBkaWZmZXJlbnQgSlNcbi8vIGV4ZWN1dGlvbiBlbnZpcm9ubWVudHMuXG52YXIgbmF0aXZlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gZ2V0SXNOYXRpdmVDaGVja2VyKHRhZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAmJiBuYXRpdmVUb1N0cmluZy5jYWxsKHYpID09PSB0YWc7IH07XG59XG5pZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGV4cG9ydHMuYmFzaWNUeXBlcy5CdWZmZXIgPSBuZXcgQmFzaWNUeXBlKGZ1bmN0aW9uICh2KSB7IHJldHVybiBCdWZmZXIuaXNCdWZmZXIodik7IH0sIFwiaXMgbm90IGEgQnVmZmVyXCIpO1xufVxudmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoYXJyYXlfMSkge1xuICAgIGV4cG9ydHMuYmFzaWNUeXBlc1thcnJheV8xLm5hbWVdID0gbmV3IEJhc2ljVHlwZShmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgaW5zdGFuY2VvZiBhcnJheV8xKTsgfSwgXCJpcyBub3QgYSBcIiArIGFycmF5XzEubmFtZSk7XG59O1xuLy8gU3VwcG9ydCB0eXBlZCBhcnJheXMgb2YgdmFyaW91cyBmbGF2b3JzXG5mb3IgKHZhciBfaSA9IDAsIF9hID0gW0ludDhBcnJheSwgVWludDhBcnJheSwgVWludDhDbGFtcGVkQXJyYXksIEludDE2QXJyYXksIFVpbnQxNkFycmF5LFxuICAgIEludDMyQXJyYXksIFVpbnQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEZsb2F0NjRBcnJheSwgQXJyYXlCdWZmZXJdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBhcnJheV8xID0gX2FbX2ldO1xuICAgIF9sb29wXzEoYXJyYXlfMSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ts-interface-checker/dist/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ts-interface-checker/dist/util.js":
/*!********************************************************!*\
  !*** ./node_modules/ts-interface-checker/dist/util.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DetailContext = exports.NoopContext = exports.VError = void 0;\n/**\n * Error thrown by validation. Besides an informative message, it includes the path to the\n * property which triggered the failure.\n */\nvar VError = /** @class */ (function (_super) {\n    __extends(VError, _super);\n    function VError(path, message) {\n        var _this = _super.call(this, message) || this;\n        _this.path = path;\n        // See https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work for info about this workaround.\n        Object.setPrototypeOf(_this, VError.prototype);\n        return _this;\n    }\n    return VError;\n}(Error));\nexports.VError = VError;\n/**\n * Fast implementation of IContext used for first-pass validation. If that fails, we can validate\n * using DetailContext to collect error messages. That's faster for the common case when messages\n * normally pass validation.\n */\nvar NoopContext = /** @class */ (function () {\n    function NoopContext() {\n    }\n    NoopContext.prototype.fail = function (relPath, message, score) {\n        return false;\n    };\n    NoopContext.prototype.unionResolver = function () { return this; };\n    NoopContext.prototype.createContext = function () { return this; };\n    NoopContext.prototype.resolveUnion = function (ur) { };\n    return NoopContext;\n}());\nexports.NoopContext = NoopContext;\n/**\n * Complete implementation of IContext that collects meaningfull errors.\n */\nvar DetailContext = /** @class */ (function () {\n    function DetailContext() {\n        // Stack of property names and associated messages for reporting helpful error messages.\n        this._propNames = [\"\"];\n        this._messages = [null];\n        // Score is used to choose the best union member whose DetailContext to use for reporting.\n        // Higher score means better match (or rather less severe mismatch).\n        this._score = 0;\n    }\n    DetailContext.prototype.fail = function (relPath, message, score) {\n        this._propNames.push(relPath);\n        this._messages.push(message);\n        this._score += score;\n        return false;\n    };\n    DetailContext.prototype.unionResolver = function () {\n        return new DetailUnionResolver();\n    };\n    DetailContext.prototype.resolveUnion = function (unionResolver) {\n        var _a, _b;\n        var u = unionResolver;\n        var best = null;\n        for (var _i = 0, _c = u.contexts; _i < _c.length; _i++) {\n            var ctx = _c[_i];\n            if (!best || ctx._score >= best._score) {\n                best = ctx;\n            }\n        }\n        if (best && best._score > 0) {\n            (_a = this._propNames).push.apply(_a, best._propNames);\n            (_b = this._messages).push.apply(_b, best._messages);\n        }\n    };\n    DetailContext.prototype.getError = function (path) {\n        var msgParts = [];\n        for (var i = this._propNames.length - 1; i >= 0; i--) {\n            var p = this._propNames[i];\n            path += (typeof p === \"number\") ? \"[\" + p + \"]\" : (p ? \".\" + p : \"\");\n            var m = this._messages[i];\n            if (m) {\n                msgParts.push(path + \" \" + m);\n            }\n        }\n        return new VError(path, msgParts.join(\"; \"));\n    };\n    DetailContext.prototype.getErrorDetail = function (path) {\n        var details = [];\n        for (var i = this._propNames.length - 1; i >= 0; i--) {\n            var p = this._propNames[i];\n            path += (typeof p === \"number\") ? \"[\" + p + \"]\" : (p ? \".\" + p : \"\");\n            var message = this._messages[i];\n            if (message) {\n                details.push({ path: path, message: message });\n            }\n        }\n        var detail = null;\n        for (var i = details.length - 1; i >= 0; i--) {\n            if (detail) {\n                details[i].nested = [detail];\n            }\n            detail = details[i];\n        }\n        return detail;\n    };\n    return DetailContext;\n}());\nexports.DetailContext = DetailContext;\nvar DetailUnionResolver = /** @class */ (function () {\n    function DetailUnionResolver() {\n        this.contexts = [];\n    }\n    DetailUnionResolver.prototype.createContext = function () {\n        var ctx = new DetailContext();\n        this.contexts.push(ctx);\n        return ctx;\n    };\n    return DetailUnionResolver;\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHMtaW50ZXJmYWNlLWNoZWNrZXIvZGlzdC91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsbUJBQW1CLEdBQUcsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsOEJBQThCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWxpYnJhcnktZG9jcy8uL25vZGVfbW9kdWxlcy90cy1pbnRlcmZhY2UtY2hlY2tlci9kaXN0L3V0aWwuanM/ZDQ1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZXRhaWxDb250ZXh0ID0gZXhwb3J0cy5Ob29wQ29udGV4dCA9IGV4cG9ydHMuVkVycm9yID0gdm9pZCAwO1xuLyoqXG4gKiBFcnJvciB0aHJvd24gYnkgdmFsaWRhdGlvbi4gQmVzaWRlcyBhbiBpbmZvcm1hdGl2ZSBtZXNzYWdlLCBpdCBpbmNsdWRlcyB0aGUgcGF0aCB0byB0aGVcbiAqIHByb3BlcnR5IHdoaWNoIHRyaWdnZXJlZCB0aGUgZmFpbHVyZS5cbiAqL1xudmFyIFZFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZFcnJvcihwYXRoLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L3dpa2kvQnJlYWtpbmctQ2hhbmdlcyNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmsgZm9yIGluZm8gYWJvdXQgdGhpcyB3b3JrYXJvdW5kLlxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFZFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBWRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlZFcnJvciA9IFZFcnJvcjtcbi8qKlxuICogRmFzdCBpbXBsZW1lbnRhdGlvbiBvZiBJQ29udGV4dCB1c2VkIGZvciBmaXJzdC1wYXNzIHZhbGlkYXRpb24uIElmIHRoYXQgZmFpbHMsIHdlIGNhbiB2YWxpZGF0ZVxuICogdXNpbmcgRGV0YWlsQ29udGV4dCB0byBjb2xsZWN0IGVycm9yIG1lc3NhZ2VzLiBUaGF0J3MgZmFzdGVyIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlbiBtZXNzYWdlc1xuICogbm9ybWFsbHkgcGFzcyB2YWxpZGF0aW9uLlxuICovXG52YXIgTm9vcENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9vcENvbnRleHQoKSB7XG4gICAgfVxuICAgIE5vb3BDb250ZXh0LnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKHJlbFBhdGgsIG1lc3NhZ2UsIHNjb3JlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIE5vb3BDb250ZXh0LnByb3RvdHlwZS51bmlvblJlc29sdmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICBOb29wQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgTm9vcENvbnRleHQucHJvdG90eXBlLnJlc29sdmVVbmlvbiA9IGZ1bmN0aW9uICh1cikgeyB9O1xuICAgIHJldHVybiBOb29wQ29udGV4dDtcbn0oKSk7XG5leHBvcnRzLk5vb3BDb250ZXh0ID0gTm9vcENvbnRleHQ7XG4vKipcbiAqIENvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIElDb250ZXh0IHRoYXQgY29sbGVjdHMgbWVhbmluZ2Z1bGwgZXJyb3JzLlxuICovXG52YXIgRGV0YWlsQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXRhaWxDb250ZXh0KCkge1xuICAgICAgICAvLyBTdGFjayBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgYXNzb2NpYXRlZCBtZXNzYWdlcyBmb3IgcmVwb3J0aW5nIGhlbHBmdWwgZXJyb3IgbWVzc2FnZXMuXG4gICAgICAgIHRoaXMuX3Byb3BOYW1lcyA9IFtcIlwiXTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbbnVsbF07XG4gICAgICAgIC8vIFNjb3JlIGlzIHVzZWQgdG8gY2hvb3NlIHRoZSBiZXN0IHVuaW9uIG1lbWJlciB3aG9zZSBEZXRhaWxDb250ZXh0IHRvIHVzZSBmb3IgcmVwb3J0aW5nLlxuICAgICAgICAvLyBIaWdoZXIgc2NvcmUgbWVhbnMgYmV0dGVyIG1hdGNoIChvciByYXRoZXIgbGVzcyBzZXZlcmUgbWlzbWF0Y2gpLlxuICAgICAgICB0aGlzLl9zY29yZSA9IDA7XG4gICAgfVxuICAgIERldGFpbENvbnRleHQucHJvdG90eXBlLmZhaWwgPSBmdW5jdGlvbiAocmVsUGF0aCwgbWVzc2FnZSwgc2NvcmUpIHtcbiAgICAgICAgdGhpcy5fcHJvcE5hbWVzLnB1c2gocmVsUGF0aCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX3Njb3JlICs9IHNjb3JlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBEZXRhaWxDb250ZXh0LnByb3RvdHlwZS51bmlvblJlc29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IERldGFpbFVuaW9uUmVzb2x2ZXIoKTtcbiAgICB9O1xuICAgIERldGFpbENvbnRleHQucHJvdG90eXBlLnJlc29sdmVVbmlvbiA9IGZ1bmN0aW9uICh1bmlvblJlc29sdmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciB1ID0gdW5pb25SZXNvbHZlcjtcbiAgICAgICAgdmFyIGJlc3QgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9jID0gdS5jb250ZXh0czsgX2kgPCBfYy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjdHggPSBfY1tfaV07XG4gICAgICAgICAgICBpZiAoIWJlc3QgfHwgY3R4Ll9zY29yZSA+PSBiZXN0Ll9zY29yZSkge1xuICAgICAgICAgICAgICAgIGJlc3QgPSBjdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlc3QgJiYgYmVzdC5fc2NvcmUgPiAwKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9wcm9wTmFtZXMpLnB1c2guYXBwbHkoX2EsIGJlc3QuX3Byb3BOYW1lcyk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLl9tZXNzYWdlcykucHVzaC5hcHBseShfYiwgYmVzdC5fbWVzc2FnZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZXRhaWxDb250ZXh0LnByb3RvdHlwZS5nZXRFcnJvciA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBtc2dQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fcHJvcE5hbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuX3Byb3BOYW1lc1tpXTtcbiAgICAgICAgICAgIHBhdGggKz0gKHR5cGVvZiBwID09PSBcIm51bWJlclwiKSA/IFwiW1wiICsgcCArIFwiXVwiIDogKHAgPyBcIi5cIiArIHAgOiBcIlwiKTtcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy5fbWVzc2FnZXNbaV07XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIG1zZ1BhcnRzLnB1c2gocGF0aCArIFwiIFwiICsgbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBWRXJyb3IocGF0aCwgbXNnUGFydHMuam9pbihcIjsgXCIpKTtcbiAgICB9O1xuICAgIERldGFpbENvbnRleHQucHJvdG90eXBlLmdldEVycm9yRGV0YWlsID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIGRldGFpbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX3Byb3BOYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLl9wcm9wTmFtZXNbaV07XG4gICAgICAgICAgICBwYXRoICs9ICh0eXBlb2YgcCA9PT0gXCJudW1iZXJcIikgPyBcIltcIiArIHAgKyBcIl1cIiA6IChwID8gXCIuXCIgKyBwIDogXCJcIik7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX21lc3NhZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goeyBwYXRoOiBwYXRoLCBtZXNzYWdlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkZXRhaWwgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gZGV0YWlscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGRldGFpbCkge1xuICAgICAgICAgICAgICAgIGRldGFpbHNbaV0ubmVzdGVkID0gW2RldGFpbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXRhaWwgPSBkZXRhaWxzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXRhaWw7XG4gICAgfTtcbiAgICByZXR1cm4gRGV0YWlsQ29udGV4dDtcbn0oKSk7XG5leHBvcnRzLkRldGFpbENvbnRleHQgPSBEZXRhaWxDb250ZXh0O1xudmFyIERldGFpbFVuaW9uUmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGV0YWlsVW5pb25SZXNvbHZlcigpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0cyA9IFtdO1xuICAgIH1cbiAgICBEZXRhaWxVbmlvblJlc29sdmVyLnByb3RvdHlwZS5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3R4ID0gbmV3IERldGFpbENvbnRleHQoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0cy5wdXNoKGN0eCk7XG4gICAgICAgIHJldHVybiBjdHg7XG4gICAgfTtcbiAgICByZXR1cm4gRGV0YWlsVW5pb25SZXNvbHZlcjtcbn0oKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ts-interface-checker/dist/util.js\n");

/***/ })

};
;