"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@jridgewell";
exports.ids = ["vendor-chunks/@jridgewell"];
exports.modules = {

/***/ "(ssr)/./node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GenMapping: () => (/* binding */ GenMapping),\n/* harmony export */   addMapping: () => (/* binding */ addMapping),\n/* harmony export */   addSegment: () => (/* binding */ addSegment),\n/* harmony export */   allMappings: () => (/* binding */ allMappings),\n/* harmony export */   fromMap: () => (/* binding */ fromMap),\n/* harmony export */   maybeAddMapping: () => (/* binding */ maybeAddMapping),\n/* harmony export */   maybeAddSegment: () => (/* binding */ maybeAddSegment),\n/* harmony export */   setIgnore: () => (/* binding */ setIgnore),\n/* harmony export */   setSourceContent: () => (/* binding */ setSourceContent),\n/* harmony export */   toDecodedMap: () => (/* binding */ toDecodedMap),\n/* harmony export */   toEncodedMap: () => (/* binding */ toEncodedMap)\n/* harmony export */ });\n/* harmony import */ var _jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jridgewell/sourcemap-codec */ \"(ssr)/./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\");\n/* harmony import */ var _jridgewell_trace_mapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jridgewell/trace-mapping */ \"(ssr)/./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs\");\n// src/set-array.ts\nvar SetArray = class {\n  constructor() {\n    this._indexes = { __proto__: null };\n    this.array = [];\n  }\n};\nfunction cast(set) {\n  return set;\n}\nfunction get(setarr, key) {\n  return cast(setarr)._indexes[key];\n}\nfunction put(setarr, key) {\n  const index = get(setarr, key);\n  if (index !== void 0) return index;\n  const { array, _indexes: indexes } = cast(setarr);\n  const length = array.push(key);\n  return indexes[key] = length - 1;\n}\nfunction remove(setarr, key) {\n  const index = get(setarr, key);\n  if (index === void 0) return;\n  const { array, _indexes: indexes } = cast(setarr);\n  for (let i = index + 1; i < array.length; i++) {\n    const k = array[i];\n    array[i - 1] = k;\n    indexes[k]--;\n  }\n  indexes[key] = void 0;\n  array.pop();\n}\n\n// src/gen-mapping.ts\n\n\n\n// src/sourcemap-segment.ts\nvar COLUMN = 0;\nvar SOURCES_INDEX = 1;\nvar SOURCE_LINE = 2;\nvar SOURCE_COLUMN = 3;\nvar NAMES_INDEX = 4;\n\n// src/gen-mapping.ts\nvar NO_NAME = -1;\nvar GenMapping = class {\n  constructor({ file, sourceRoot } = {}) {\n    this._names = new SetArray();\n    this._sources = new SetArray();\n    this._sourcesContent = [];\n    this._mappings = [];\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n    this._ignoreList = new SetArray();\n  }\n};\nfunction cast2(map) {\n  return map;\n}\nfunction addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n  return addSegmentInternal(\n    false,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content\n  );\n}\nfunction addMapping(map, mapping) {\n  return addMappingInternal(false, map, mapping);\n}\nvar maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n  return addSegmentInternal(\n    true,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content\n  );\n};\nvar maybeAddMapping = (map, mapping) => {\n  return addMappingInternal(true, map, mapping);\n};\nfunction setSourceContent(map, source, content) {\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent\n    // _originalScopes: originalScopes,\n  } = cast2(map);\n  const index = put(sources, source);\n  sourcesContent[index] = content;\n}\nfunction setIgnore(map, source, ignore = true) {\n  const {\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _ignoreList: ignoreList\n    // _originalScopes: originalScopes,\n  } = cast2(map);\n  const index = put(sources, source);\n  if (index === sourcesContent.length) sourcesContent[index] = null;\n  if (ignore) put(ignoreList, index);\n  else remove(ignoreList, index);\n}\nfunction toDecodedMap(map) {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n    _ignoreList: ignoreList\n    // _originalScopes: originalScopes,\n    // _generatedRanges: generatedRanges,\n  } = cast2(map);\n  removeEmptyFinalLines(mappings);\n  return {\n    version: 3,\n    file: map.file || void 0,\n    names: names.array,\n    sourceRoot: map.sourceRoot || void 0,\n    sources: sources.array,\n    sourcesContent,\n    mappings,\n    // originalScopes,\n    // generatedRanges,\n    ignoreList: ignoreList.array\n  };\n}\nfunction toEncodedMap(map) {\n  const decoded = toDecodedMap(map);\n  return Object.assign({}, decoded, {\n    // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),\n    // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),\n    mappings: (0,_jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_0__.encode)(decoded.mappings)\n  });\n}\nfunction fromMap(input) {\n  const map = new _jridgewell_trace_mapping__WEBPACK_IMPORTED_MODULE_1__.TraceMap(input);\n  const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n  putAll(cast2(gen)._names, map.names);\n  putAll(cast2(gen)._sources, map.sources);\n  cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n  cast2(gen)._mappings = (0,_jridgewell_trace_mapping__WEBPACK_IMPORTED_MODULE_1__.decodedMappings)(map);\n  if (map.ignoreList) putAll(cast2(gen)._ignoreList, map.ignoreList);\n  return gen;\n}\nfunction allMappings(map) {\n  const out = [];\n  const { _mappings: mappings, _sources: sources, _names: names } = cast2(map);\n  for (let i = 0; i < mappings.length; i++) {\n    const line = mappings[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const generated = { line: i + 1, column: seg[COLUMN] };\n      let source = void 0;\n      let original = void 0;\n      let name = void 0;\n      if (seg.length !== 1) {\n        source = sources.array[seg[SOURCES_INDEX]];\n        original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n        if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n      }\n      out.push({ generated, source, original, name });\n    }\n  }\n  return out;\n}\nfunction addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names\n    // _originalScopes: originalScopes,\n  } = cast2(map);\n  const line = getIndex(mappings, genLine);\n  const index = getColumnIndex(line, genColumn);\n  if (!source) {\n    if (skipable && skipSourceless(line, index)) return;\n    return insert(line, index, [genColumn]);\n  }\n  assert(sourceLine);\n  assert(sourceColumn);\n  const sourcesIndex = put(sources, source);\n  const namesIndex = name ? put(names, name) : NO_NAME;\n  if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;\n  if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n    return;\n  }\n  return insert(\n    line,\n    index,\n    name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]\n  );\n}\nfunction assert(_val) {\n}\nfunction getIndex(arr, index) {\n  for (let i = arr.length; i <= index; i++) {\n    arr[i] = [];\n  }\n  return arr[index];\n}\nfunction getColumnIndex(line, genColumn) {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\nfunction insert(array, index, value) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\nfunction removeEmptyFinalLines(mappings) {\n  const { length } = mappings;\n  let len = length;\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\nfunction putAll(setarr, array) {\n  for (let i = 0; i < array.length; i++) put(setarr, array[i]);\n}\nfunction skipSourceless(line, index) {\n  if (index === 0) return true;\n  const prev = line[index - 1];\n  return prev.length === 1;\n}\nfunction skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n  if (index === 0) return false;\n  const prev = line[index - 1];\n  if (prev.length === 1) return false;\n  return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);\n}\nfunction addMappingInternal(skipable, map, mapping) {\n  const { generated, source, original, name, content } = mapping;\n  if (!source) {\n    return addSegmentInternal(\n      skipable,\n      map,\n      generated.line - 1,\n      generated.column,\n      null,\n      null,\n      null,\n      null,\n      null\n    );\n  }\n  assert(original);\n  return addSegmentInternal(\n    skipable,\n    map,\n    generated.line - 1,\n    generated.column,\n    source,\n    original.line - 1,\n    original.column,\n    name,\n    content\n  );\n}\n\n//# sourceMappingURL=gen-mapping.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvZ2VuLW1hcHBpbmcvZGlzdC9nZW4tbWFwcGluZy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQywwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR3FDO0FBQ2lDOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQixJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxjQUFjLG1FQUFNO0FBQ3BCLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0JBQWtCLCtEQUFRO0FBQzFCLCtCQUErQiw0Q0FBNEM7QUFDM0U7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBFQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUF3RDtBQUNsRSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUIsbUNBQW1DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkNBQTZDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFhRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdWktbGlicmFyeS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL2dlbi1tYXBwaW5nL2Rpc3QvZ2VuLW1hcHBpbmcubWpzP2Q3YTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3NldC1hcnJheS50c1xudmFyIFNldEFycmF5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbmRleGVzID0geyBfX3Byb3RvX186IG51bGwgfTtcbiAgICB0aGlzLmFycmF5ID0gW107XG4gIH1cbn07XG5mdW5jdGlvbiBjYXN0KHNldCkge1xuICByZXR1cm4gc2V0O1xufVxuZnVuY3Rpb24gZ2V0KHNldGFyciwga2V5KSB7XG4gIHJldHVybiBjYXN0KHNldGFycikuX2luZGV4ZXNba2V5XTtcbn1cbmZ1bmN0aW9uIHB1dChzZXRhcnIsIGtleSkge1xuICBjb25zdCBpbmRleCA9IGdldChzZXRhcnIsIGtleSk7XG4gIGlmIChpbmRleCAhPT0gdm9pZCAwKSByZXR1cm4gaW5kZXg7XG4gIGNvbnN0IHsgYXJyYXksIF9pbmRleGVzOiBpbmRleGVzIH0gPSBjYXN0KHNldGFycik7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5LnB1c2goa2V5KTtcbiAgcmV0dXJuIGluZGV4ZXNba2V5XSA9IGxlbmd0aCAtIDE7XG59XG5mdW5jdGlvbiByZW1vdmUoc2V0YXJyLCBrZXkpIHtcbiAgY29uc3QgaW5kZXggPSBnZXQoc2V0YXJyLCBrZXkpO1xuICBpZiAoaW5kZXggPT09IHZvaWQgMCkgcmV0dXJuO1xuICBjb25zdCB7IGFycmF5LCBfaW5kZXhlczogaW5kZXhlcyB9ID0gY2FzdChzZXRhcnIpO1xuICBmb3IgKGxldCBpID0gaW5kZXggKyAxOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaSAtIDFdID0gaztcbiAgICBpbmRleGVzW2tdLS07XG4gIH1cbiAgaW5kZXhlc1trZXldID0gdm9pZCAwO1xuICBhcnJheS5wb3AoKTtcbn1cblxuLy8gc3JjL2dlbi1tYXBwaW5nLnRzXG5pbXBvcnQge1xuICBlbmNvZGVcbn0gZnJvbSBcIkBqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlY1wiO1xuaW1wb3J0IHsgVHJhY2VNYXAsIGRlY29kZWRNYXBwaW5ncyB9IGZyb20gXCJAanJpZGdld2VsbC90cmFjZS1tYXBwaW5nXCI7XG5cbi8vIHNyYy9zb3VyY2VtYXAtc2VnbWVudC50c1xudmFyIENPTFVNTiA9IDA7XG52YXIgU09VUkNFU19JTkRFWCA9IDE7XG52YXIgU09VUkNFX0xJTkUgPSAyO1xudmFyIFNPVVJDRV9DT0xVTU4gPSAzO1xudmFyIE5BTUVTX0lOREVYID0gNDtcblxuLy8gc3JjL2dlbi1tYXBwaW5nLnRzXG52YXIgTk9fTkFNRSA9IC0xO1xudmFyIEdlbk1hcHBpbmcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHsgZmlsZSwgc291cmNlUm9vdCB9ID0ge30pIHtcbiAgICB0aGlzLl9uYW1lcyA9IG5ldyBTZXRBcnJheSgpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgU2V0QXJyYXkoKTtcbiAgICB0aGlzLl9zb3VyY2VzQ29udGVudCA9IFtdO1xuICAgIHRoaXMuX21hcHBpbmdzID0gW107XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICAgIHRoaXMuX2lnbm9yZUxpc3QgPSBuZXcgU2V0QXJyYXkoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNhc3QyKG1hcCkge1xuICByZXR1cm4gbWFwO1xufVxuZnVuY3Rpb24gYWRkU2VnbWVudChtYXAsIGdlbkxpbmUsIGdlbkNvbHVtbiwgc291cmNlLCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWUsIGNvbnRlbnQpIHtcbiAgcmV0dXJuIGFkZFNlZ21lbnRJbnRlcm5hbChcbiAgICBmYWxzZSxcbiAgICBtYXAsXG4gICAgZ2VuTGluZSxcbiAgICBnZW5Db2x1bW4sXG4gICAgc291cmNlLFxuICAgIHNvdXJjZUxpbmUsXG4gICAgc291cmNlQ29sdW1uLFxuICAgIG5hbWUsXG4gICAgY29udGVudFxuICApO1xufVxuZnVuY3Rpb24gYWRkTWFwcGluZyhtYXAsIG1hcHBpbmcpIHtcbiAgcmV0dXJuIGFkZE1hcHBpbmdJbnRlcm5hbChmYWxzZSwgbWFwLCBtYXBwaW5nKTtcbn1cbnZhciBtYXliZUFkZFNlZ21lbnQgPSAobWFwLCBnZW5MaW5lLCBnZW5Db2x1bW4sIHNvdXJjZSwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lLCBjb250ZW50KSA9PiB7XG4gIHJldHVybiBhZGRTZWdtZW50SW50ZXJuYWwoXG4gICAgdHJ1ZSxcbiAgICBtYXAsXG4gICAgZ2VuTGluZSxcbiAgICBnZW5Db2x1bW4sXG4gICAgc291cmNlLFxuICAgIHNvdXJjZUxpbmUsXG4gICAgc291cmNlQ29sdW1uLFxuICAgIG5hbWUsXG4gICAgY29udGVudFxuICApO1xufTtcbnZhciBtYXliZUFkZE1hcHBpbmcgPSAobWFwLCBtYXBwaW5nKSA9PiB7XG4gIHJldHVybiBhZGRNYXBwaW5nSW50ZXJuYWwodHJ1ZSwgbWFwLCBtYXBwaW5nKTtcbn07XG5mdW5jdGlvbiBzZXRTb3VyY2VDb250ZW50KG1hcCwgc291cmNlLCBjb250ZW50KSB7XG4gIGNvbnN0IHtcbiAgICBfc291cmNlczogc291cmNlcyxcbiAgICBfc291cmNlc0NvbnRlbnQ6IHNvdXJjZXNDb250ZW50XG4gICAgLy8gX29yaWdpbmFsU2NvcGVzOiBvcmlnaW5hbFNjb3BlcyxcbiAgfSA9IGNhc3QyKG1hcCk7XG4gIGNvbnN0IGluZGV4ID0gcHV0KHNvdXJjZXMsIHNvdXJjZSk7XG4gIHNvdXJjZXNDb250ZW50W2luZGV4XSA9IGNvbnRlbnQ7XG59XG5mdW5jdGlvbiBzZXRJZ25vcmUobWFwLCBzb3VyY2UsIGlnbm9yZSA9IHRydWUpIHtcbiAgY29uc3Qge1xuICAgIF9zb3VyY2VzOiBzb3VyY2VzLFxuICAgIF9zb3VyY2VzQ29udGVudDogc291cmNlc0NvbnRlbnQsXG4gICAgX2lnbm9yZUxpc3Q6IGlnbm9yZUxpc3RcbiAgICAvLyBfb3JpZ2luYWxTY29wZXM6IG9yaWdpbmFsU2NvcGVzLFxuICB9ID0gY2FzdDIobWFwKTtcbiAgY29uc3QgaW5kZXggPSBwdXQoc291cmNlcywgc291cmNlKTtcbiAgaWYgKGluZGV4ID09PSBzb3VyY2VzQ29udGVudC5sZW5ndGgpIHNvdXJjZXNDb250ZW50W2luZGV4XSA9IG51bGw7XG4gIGlmIChpZ25vcmUpIHB1dChpZ25vcmVMaXN0LCBpbmRleCk7XG4gIGVsc2UgcmVtb3ZlKGlnbm9yZUxpc3QsIGluZGV4KTtcbn1cbmZ1bmN0aW9uIHRvRGVjb2RlZE1hcChtYXApIHtcbiAgY29uc3Qge1xuICAgIF9tYXBwaW5nczogbWFwcGluZ3MsXG4gICAgX3NvdXJjZXM6IHNvdXJjZXMsXG4gICAgX3NvdXJjZXNDb250ZW50OiBzb3VyY2VzQ29udGVudCxcbiAgICBfbmFtZXM6IG5hbWVzLFxuICAgIF9pZ25vcmVMaXN0OiBpZ25vcmVMaXN0XG4gICAgLy8gX29yaWdpbmFsU2NvcGVzOiBvcmlnaW5hbFNjb3BlcyxcbiAgICAvLyBfZ2VuZXJhdGVkUmFuZ2VzOiBnZW5lcmF0ZWRSYW5nZXMsXG4gIH0gPSBjYXN0MihtYXApO1xuICByZW1vdmVFbXB0eUZpbmFsTGluZXMobWFwcGluZ3MpO1xuICByZXR1cm4ge1xuICAgIHZlcnNpb246IDMsXG4gICAgZmlsZTogbWFwLmZpbGUgfHwgdm9pZCAwLFxuICAgIG5hbWVzOiBuYW1lcy5hcnJheSxcbiAgICBzb3VyY2VSb290OiBtYXAuc291cmNlUm9vdCB8fCB2b2lkIDAsXG4gICAgc291cmNlczogc291cmNlcy5hcnJheSxcbiAgICBzb3VyY2VzQ29udGVudCxcbiAgICBtYXBwaW5ncyxcbiAgICAvLyBvcmlnaW5hbFNjb3BlcyxcbiAgICAvLyBnZW5lcmF0ZWRSYW5nZXMsXG4gICAgaWdub3JlTGlzdDogaWdub3JlTGlzdC5hcnJheVxuICB9O1xufVxuZnVuY3Rpb24gdG9FbmNvZGVkTWFwKG1hcCkge1xuICBjb25zdCBkZWNvZGVkID0gdG9EZWNvZGVkTWFwKG1hcCk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWNvZGVkLCB7XG4gICAgLy8gb3JpZ2luYWxTY29wZXM6IGRlY29kZWQub3JpZ2luYWxTY29wZXMubWFwKChvcykgPT4gZW5jb2RlT3JpZ2luYWxTY29wZXMob3MpKSxcbiAgICAvLyBnZW5lcmF0ZWRSYW5nZXM6IGVuY29kZUdlbmVyYXRlZFJhbmdlcyhkZWNvZGVkLmdlbmVyYXRlZFJhbmdlcyBhcyBHZW5lcmF0ZWRSYW5nZVtdKSxcbiAgICBtYXBwaW5nczogZW5jb2RlKGRlY29kZWQubWFwcGluZ3MpXG4gIH0pO1xufVxuZnVuY3Rpb24gZnJvbU1hcChpbnB1dCkge1xuICBjb25zdCBtYXAgPSBuZXcgVHJhY2VNYXAoaW5wdXQpO1xuICBjb25zdCBnZW4gPSBuZXcgR2VuTWFwcGluZyh7IGZpbGU6IG1hcC5maWxlLCBzb3VyY2VSb290OiBtYXAuc291cmNlUm9vdCB9KTtcbiAgcHV0QWxsKGNhc3QyKGdlbikuX25hbWVzLCBtYXAubmFtZXMpO1xuICBwdXRBbGwoY2FzdDIoZ2VuKS5fc291cmNlcywgbWFwLnNvdXJjZXMpO1xuICBjYXN0MihnZW4pLl9zb3VyY2VzQ29udGVudCA9IG1hcC5zb3VyY2VzQ29udGVudCB8fCBtYXAuc291cmNlcy5tYXAoKCkgPT4gbnVsbCk7XG4gIGNhc3QyKGdlbikuX21hcHBpbmdzID0gZGVjb2RlZE1hcHBpbmdzKG1hcCk7XG4gIGlmIChtYXAuaWdub3JlTGlzdCkgcHV0QWxsKGNhc3QyKGdlbikuX2lnbm9yZUxpc3QsIG1hcC5pZ25vcmVMaXN0KTtcbiAgcmV0dXJuIGdlbjtcbn1cbmZ1bmN0aW9uIGFsbE1hcHBpbmdzKG1hcCkge1xuICBjb25zdCBvdXQgPSBbXTtcbiAgY29uc3QgeyBfbWFwcGluZ3M6IG1hcHBpbmdzLCBfc291cmNlczogc291cmNlcywgX25hbWVzOiBuYW1lcyB9ID0gY2FzdDIobWFwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBwaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBtYXBwaW5nc1tpXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHNlZyA9IGxpbmVbal07XG4gICAgICBjb25zdCBnZW5lcmF0ZWQgPSB7IGxpbmU6IGkgKyAxLCBjb2x1bW46IHNlZ1tDT0xVTU5dIH07XG4gICAgICBsZXQgc291cmNlID0gdm9pZCAwO1xuICAgICAgbGV0IG9yaWdpbmFsID0gdm9pZCAwO1xuICAgICAgbGV0IG5hbWUgPSB2b2lkIDA7XG4gICAgICBpZiAoc2VnLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICBzb3VyY2UgPSBzb3VyY2VzLmFycmF5W3NlZ1tTT1VSQ0VTX0lOREVYXV07XG4gICAgICAgIG9yaWdpbmFsID0geyBsaW5lOiBzZWdbU09VUkNFX0xJTkVdICsgMSwgY29sdW1uOiBzZWdbU09VUkNFX0NPTFVNTl0gfTtcbiAgICAgICAgaWYgKHNlZy5sZW5ndGggPT09IDUpIG5hbWUgPSBuYW1lcy5hcnJheVtzZWdbTkFNRVNfSU5ERVhdXTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKHsgZ2VuZXJhdGVkLCBzb3VyY2UsIG9yaWdpbmFsLCBuYW1lIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gYWRkU2VnbWVudEludGVybmFsKHNraXBhYmxlLCBtYXAsIGdlbkxpbmUsIGdlbkNvbHVtbiwgc291cmNlLCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWUsIGNvbnRlbnQpIHtcbiAgY29uc3Qge1xuICAgIF9tYXBwaW5nczogbWFwcGluZ3MsXG4gICAgX3NvdXJjZXM6IHNvdXJjZXMsXG4gICAgX3NvdXJjZXNDb250ZW50OiBzb3VyY2VzQ29udGVudCxcbiAgICBfbmFtZXM6IG5hbWVzXG4gICAgLy8gX29yaWdpbmFsU2NvcGVzOiBvcmlnaW5hbFNjb3BlcyxcbiAgfSA9IGNhc3QyKG1hcCk7XG4gIGNvbnN0IGxpbmUgPSBnZXRJbmRleChtYXBwaW5ncywgZ2VuTGluZSk7XG4gIGNvbnN0IGluZGV4ID0gZ2V0Q29sdW1uSW5kZXgobGluZSwgZ2VuQ29sdW1uKTtcbiAgaWYgKCFzb3VyY2UpIHtcbiAgICBpZiAoc2tpcGFibGUgJiYgc2tpcFNvdXJjZWxlc3MobGluZSwgaW5kZXgpKSByZXR1cm47XG4gICAgcmV0dXJuIGluc2VydChsaW5lLCBpbmRleCwgW2dlbkNvbHVtbl0pO1xuICB9XG4gIGFzc2VydChzb3VyY2VMaW5lKTtcbiAgYXNzZXJ0KHNvdXJjZUNvbHVtbik7XG4gIGNvbnN0IHNvdXJjZXNJbmRleCA9IHB1dChzb3VyY2VzLCBzb3VyY2UpO1xuICBjb25zdCBuYW1lc0luZGV4ID0gbmFtZSA/IHB1dChuYW1lcywgbmFtZSkgOiBOT19OQU1FO1xuICBpZiAoc291cmNlc0luZGV4ID09PSBzb3VyY2VzQ29udGVudC5sZW5ndGgpIHNvdXJjZXNDb250ZW50W3NvdXJjZXNJbmRleF0gPSBjb250ZW50ICE9IG51bGwgPyBjb250ZW50IDogbnVsbDtcbiAgaWYgKHNraXBhYmxlICYmIHNraXBTb3VyY2UobGluZSwgaW5kZXgsIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lc0luZGV4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gaW5zZXJ0KFxuICAgIGxpbmUsXG4gICAgaW5kZXgsXG4gICAgbmFtZSA/IFtnZW5Db2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lc0luZGV4XSA6IFtnZW5Db2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uXVxuICApO1xufVxuZnVuY3Rpb24gYXNzZXJ0KF92YWwpIHtcbn1cbmZ1bmN0aW9uIGdldEluZGV4KGFyciwgaW5kZXgpIHtcbiAgZm9yIChsZXQgaSA9IGFyci5sZW5ndGg7IGkgPD0gaW5kZXg7IGkrKykge1xuICAgIGFycltpXSA9IFtdO1xuICB9XG4gIHJldHVybiBhcnJbaW5kZXhdO1xufVxuZnVuY3Rpb24gZ2V0Q29sdW1uSW5kZXgobGluZSwgZ2VuQ29sdW1uKSB7XG4gIGxldCBpbmRleCA9IGxpbmUubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gaW5kZXggLSAxOyBpID49IDA7IGluZGV4ID0gaS0tKSB7XG4gICAgY29uc3QgY3VycmVudCA9IGxpbmVbaV07XG4gICAgaWYgKGdlbkNvbHVtbiA+PSBjdXJyZW50W0NPTFVNTl0pIGJyZWFrO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGluc2VydChhcnJheSwgaW5kZXgsIHZhbHVlKSB7XG4gIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGg7IGkgPiBpbmRleDsgaS0tKSB7XG4gICAgYXJyYXlbaV0gPSBhcnJheVtpIC0gMV07XG4gIH1cbiAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG59XG5mdW5jdGlvbiByZW1vdmVFbXB0eUZpbmFsTGluZXMobWFwcGluZ3MpIHtcbiAgY29uc3QgeyBsZW5ndGggfSA9IG1hcHBpbmdzO1xuICBsZXQgbGVuID0gbGVuZ3RoO1xuICBmb3IgKGxldCBpID0gbGVuIC0gMTsgaSA+PSAwOyBsZW4gPSBpLCBpLS0pIHtcbiAgICBpZiAobWFwcGluZ3NbaV0ubGVuZ3RoID4gMCkgYnJlYWs7XG4gIH1cbiAgaWYgKGxlbiA8IGxlbmd0aCkgbWFwcGluZ3MubGVuZ3RoID0gbGVuO1xufVxuZnVuY3Rpb24gcHV0QWxsKHNldGFyciwgYXJyYXkpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgcHV0KHNldGFyciwgYXJyYXlbaV0pO1xufVxuZnVuY3Rpb24gc2tpcFNvdXJjZWxlc3MobGluZSwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgcHJldiA9IGxpbmVbaW5kZXggLSAxXTtcbiAgcmV0dXJuIHByZXYubGVuZ3RoID09PSAxO1xufVxuZnVuY3Rpb24gc2tpcFNvdXJjZShsaW5lLCBpbmRleCwgc291cmNlc0luZGV4LCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWVzSW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByZXYgPSBsaW5lW2luZGV4IC0gMV07XG4gIGlmIChwcmV2Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gc291cmNlc0luZGV4ID09PSBwcmV2W1NPVVJDRVNfSU5ERVhdICYmIHNvdXJjZUxpbmUgPT09IHByZXZbU09VUkNFX0xJTkVdICYmIHNvdXJjZUNvbHVtbiA9PT0gcHJldltTT1VSQ0VfQ09MVU1OXSAmJiBuYW1lc0luZGV4ID09PSAocHJldi5sZW5ndGggPT09IDUgPyBwcmV2W05BTUVTX0lOREVYXSA6IE5PX05BTUUpO1xufVxuZnVuY3Rpb24gYWRkTWFwcGluZ0ludGVybmFsKHNraXBhYmxlLCBtYXAsIG1hcHBpbmcpIHtcbiAgY29uc3QgeyBnZW5lcmF0ZWQsIHNvdXJjZSwgb3JpZ2luYWwsIG5hbWUsIGNvbnRlbnQgfSA9IG1hcHBpbmc7XG4gIGlmICghc291cmNlKSB7XG4gICAgcmV0dXJuIGFkZFNlZ21lbnRJbnRlcm5hbChcbiAgICAgIHNraXBhYmxlLFxuICAgICAgbWFwLFxuICAgICAgZ2VuZXJhdGVkLmxpbmUgLSAxLFxuICAgICAgZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgIG51bGwsXG4gICAgICBudWxsLFxuICAgICAgbnVsbCxcbiAgICAgIG51bGwsXG4gICAgICBudWxsXG4gICAgKTtcbiAgfVxuICBhc3NlcnQob3JpZ2luYWwpO1xuICByZXR1cm4gYWRkU2VnbWVudEludGVybmFsKFxuICAgIHNraXBhYmxlLFxuICAgIG1hcCxcbiAgICBnZW5lcmF0ZWQubGluZSAtIDEsXG4gICAgZ2VuZXJhdGVkLmNvbHVtbixcbiAgICBzb3VyY2UsXG4gICAgb3JpZ2luYWwubGluZSAtIDEsXG4gICAgb3JpZ2luYWwuY29sdW1uLFxuICAgIG5hbWUsXG4gICAgY29udGVudFxuICApO1xufVxuZXhwb3J0IHtcbiAgR2VuTWFwcGluZyxcbiAgYWRkTWFwcGluZyxcbiAgYWRkU2VnbWVudCxcbiAgYWxsTWFwcGluZ3MsXG4gIGZyb21NYXAsXG4gIG1heWJlQWRkTWFwcGluZyxcbiAgbWF5YmVBZGRTZWdtZW50LFxuICBzZXRJZ25vcmUsXG4gIHNldFNvdXJjZUNvbnRlbnQsXG4gIHRvRGVjb2RlZE1hcCxcbiAgdG9FbmNvZGVkTWFwXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuLW1hcHBpbmcubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ resolve)\n/* harmony export */ });\n// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\nfunction isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n}\nfunction isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n}\nfunction isAbsolutePath(input) {\n    return input.startsWith('/');\n}\nfunction isFileUrl(input) {\n    return input.startsWith('file:');\n}\nfunction isRelative(input) {\n    return /^[.?#]/.test(input);\n}\nfunction parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n}\nfunction parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n}\nfunction makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n        scheme,\n        user,\n        host,\n        port,\n        path,\n        query,\n        hash,\n        type: 7 /* Absolute */,\n    };\n}\nfunction parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n        const url = parseAbsoluteUrl('http:' + input);\n        url.scheme = '';\n        url.type = 6 /* SchemeRelative */;\n        return url;\n    }\n    if (isAbsolutePath(input)) {\n        const url = parseAbsoluteUrl('http://foo.com' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = 5 /* AbsolutePath */;\n        return url;\n    }\n    if (isFileUrl(input))\n        return parseFileUrl(input);\n    if (isAbsoluteUrl(input))\n        return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input\n        ? input.startsWith('?')\n            ? 3 /* Query */\n            : input.startsWith('#')\n                ? 2 /* Hash */\n                : 4 /* RelativePath */\n        : 1 /* Empty */;\n    return url;\n}\nfunction stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..'))\n        return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\nfunction mergePaths(url, base) {\n    normalizePath(base, base.type);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n        url.path = base.path;\n    }\n    else {\n        // Resolution happens relative to the base path's directory, not the file.\n        url.path = stripPathFilename(base.path) + url.path;\n    }\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url, type) {\n    const rel = type <= 4 /* RelativePath */;\n    const pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n        const piece = pieces[i];\n        // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n        if (!piece) {\n            addTrailingSlash = true;\n            continue;\n        }\n        // If we encounter a real directory, then we don't need to append anymore.\n        addTrailingSlash = false;\n        // A current directory, which we can always drop.\n        if (piece === '.')\n            continue;\n        // A parent directory, we need to see if there are any real directories we can pop. Else, we\n        // have an excess of parents, and we'll need to keep the \"..\".\n        if (piece === '..') {\n            if (positive) {\n                addTrailingSlash = true;\n                positive--;\n                pointer--;\n            }\n            else if (rel) {\n                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                pieces[pointer++] = piece;\n            }\n            continue;\n        }\n        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n        // any popped or dropped directories.\n        pieces[pointer++] = piece;\n        positive++;\n    }\n    let path = '';\n    for (let i = 1; i < pointer; i++) {\n        path += '/' + pieces[i];\n    }\n    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n        path += '/';\n    }\n    url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nfunction resolve(input, base) {\n    if (!input && !base)\n        return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n    if (base && inputType !== 7 /* Absolute */) {\n        const baseUrl = parseUrl(base);\n        const baseType = baseUrl.type;\n        switch (inputType) {\n            case 1 /* Empty */:\n                url.hash = baseUrl.hash;\n            // fall through\n            case 2 /* Hash */:\n                url.query = baseUrl.query;\n            // fall through\n            case 3 /* Query */:\n            case 4 /* RelativePath */:\n                mergePaths(url, baseUrl);\n            // fall through\n            case 5 /* AbsolutePath */:\n                // The host, user, and port are joined, you can't copy one without the others.\n                url.user = baseUrl.user;\n                url.host = baseUrl.host;\n                url.port = baseUrl.port;\n            // fall through\n            case 6 /* SchemeRelative */:\n                // The input doesn't have a schema at least, so we need to copy at least that over.\n                url.scheme = baseUrl.scheme;\n        }\n        if (baseType > inputType)\n            inputType = baseType;\n    }\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n    switch (inputType) {\n        // This is impossible, because of the empty checks at the start of the function.\n        // case UrlType.Empty:\n        case 2 /* Hash */:\n        case 3 /* Query */:\n            return queryHash;\n        case 4 /* RelativePath */: {\n            // The first char is always a \"/\", and we need it to be relative.\n            const path = url.path.slice(1);\n            if (!path)\n                return queryHash || '.';\n            if (isRelative(base || input) && !isRelative(path)) {\n                // If base started with a leading \".\", or there is no base and input started with a \".\",\n                // then we need to ensure that the relative path starts with a \".\". We don't know if\n                // relative starts with a \"..\", though, so check before prepending.\n                return './' + path + queryHash;\n            }\n            return path + queryHash;\n        }\n        case 5 /* AbsolutePath */:\n            return url.path + queryHash;\n        default:\n            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n}\n\n\n//# sourceMappingURL=resolve-uri.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvcmVzb2x2ZS11cmkvZGlzdC9yZXNvbHZlLXVyaS5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91aS1saWJyYXJ5LWRvY3MvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvcmVzb2x2ZS11cmkvZGlzdC9yZXNvbHZlLXVyaS5tanM/YjIwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNYXRjaGVzIHRoZSBzY2hlbWUgb2YgYSBVUkwsIGVnIFwiaHR0cDovL1wiXG5jb25zdCBzY2hlbWVSZWdleCA9IC9eW1xcdysuLV0rOlxcL1xcLy87XG4vKipcbiAqIE1hdGNoZXMgdGhlIHBhcnRzIG9mIGEgVVJMOlxuICogMS4gU2NoZW1lLCBpbmNsdWRpbmcgXCI6XCIsIGd1YXJhbnRlZWQuXG4gKiAyLiBVc2VyL3Bhc3N3b3JkLCBpbmNsdWRpbmcgXCJAXCIsIG9wdGlvbmFsLlxuICogMy4gSG9zdCwgZ3VhcmFudGVlZC5cbiAqIDQuIFBvcnQsIGluY2x1ZGluZyBcIjpcIiwgb3B0aW9uYWwuXG4gKiA1LiBQYXRoLCBpbmNsdWRpbmcgXCIvXCIsIG9wdGlvbmFsLlxuICogNi4gUXVlcnksIGluY2x1ZGluZyBcIj9cIiwgb3B0aW9uYWwuXG4gKiA3LiBIYXNoLCBpbmNsdWRpbmcgXCIjXCIsIG9wdGlvbmFsLlxuICovXG5jb25zdCB1cmxSZWdleCA9IC9eKFtcXHcrLi1dKzopXFwvXFwvKFteQC8jP10qQCk/KFteOi8jP10qKSg6XFxkKyk/KFxcL1teIz9dKik/KFxcP1teI10qKT8oIy4qKT8vO1xuLyoqXG4gKiBGaWxlIFVSTHMgYXJlIHdlaXJkLiBUaGV5IGRvbnQnIG5lZWQgdGhlIHJlZ3VsYXIgYC8vYCBpbiB0aGUgc2NoZW1lLCB0aGV5IG1heSBvciBtYXkgbm90IHN0YXJ0XG4gKiB3aXRoIGEgbGVhZGluZyBgL2AsIHRoZXkgY2FuIGhhdmUgYSBkb21haW4gKGJ1dCBvbmx5IGlmIHRoZXkgZG9uJ3Qgc3RhcnQgd2l0aCBhIFdpbmRvd3MgZHJpdmUpLlxuICpcbiAqIDEuIEhvc3QsIG9wdGlvbmFsLlxuICogMi4gUGF0aCwgd2hpY2ggbWF5IGluY2x1ZGUgXCIvXCIsIGd1YXJhbnRlZWQuXG4gKiAzLiBRdWVyeSwgaW5jbHVkaW5nIFwiP1wiLCBvcHRpb25hbC5cbiAqIDQuIEhhc2gsIGluY2x1ZGluZyBcIiNcIiwgb3B0aW9uYWwuXG4gKi9cbmNvbnN0IGZpbGVSZWdleCA9IC9eZmlsZTooPzpcXC9cXC8oKD8hW2Etel06KVteLyM/XSopPyk/KFxcLz9bXiM/XSopKFxcP1teI10qKT8oIy4qKT8vaTtcbmZ1bmN0aW9uIGlzQWJzb2x1dGVVcmwoaW5wdXQpIHtcbiAgICByZXR1cm4gc2NoZW1lUmVnZXgudGVzdChpbnB1dCk7XG59XG5mdW5jdGlvbiBpc1NjaGVtZVJlbGF0aXZlVXJsKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnN0YXJ0c1dpdGgoJy8vJyk7XG59XG5mdW5jdGlvbiBpc0Fic29sdXRlUGF0aChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5zdGFydHNXaXRoKCcvJyk7XG59XG5mdW5jdGlvbiBpc0ZpbGVVcmwoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQuc3RhcnRzV2l0aCgnZmlsZTonKTtcbn1cbmZ1bmN0aW9uIGlzUmVsYXRpdmUoaW5wdXQpIHtcbiAgICByZXR1cm4gL15bLj8jXS8udGVzdChpbnB1dCk7XG59XG5mdW5jdGlvbiBwYXJzZUFic29sdXRlVXJsKGlucHV0KSB7XG4gICAgY29uc3QgbWF0Y2ggPSB1cmxSZWdleC5leGVjKGlucHV0KTtcbiAgICByZXR1cm4gbWFrZVVybChtYXRjaFsxXSwgbWF0Y2hbMl0gfHwgJycsIG1hdGNoWzNdLCBtYXRjaFs0XSB8fCAnJywgbWF0Y2hbNV0gfHwgJy8nLCBtYXRjaFs2XSB8fCAnJywgbWF0Y2hbN10gfHwgJycpO1xufVxuZnVuY3Rpb24gcGFyc2VGaWxlVXJsKGlucHV0KSB7XG4gICAgY29uc3QgbWF0Y2ggPSBmaWxlUmVnZXguZXhlYyhpbnB1dCk7XG4gICAgY29uc3QgcGF0aCA9IG1hdGNoWzJdO1xuICAgIHJldHVybiBtYWtlVXJsKCdmaWxlOicsICcnLCBtYXRjaFsxXSB8fCAnJywgJycsIGlzQWJzb2x1dGVQYXRoKHBhdGgpID8gcGF0aCA6ICcvJyArIHBhdGgsIG1hdGNoWzNdIHx8ICcnLCBtYXRjaFs0XSB8fCAnJyk7XG59XG5mdW5jdGlvbiBtYWtlVXJsKHNjaGVtZSwgdXNlciwgaG9zdCwgcG9ydCwgcGF0aCwgcXVlcnksIGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWUsXG4gICAgICAgIHVzZXIsXG4gICAgICAgIGhvc3QsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBoYXNoLFxuICAgICAgICB0eXBlOiA3IC8qIEFic29sdXRlICovLFxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZVVybChpbnB1dCkge1xuICAgIGlmIChpc1NjaGVtZVJlbGF0aXZlVXJsKGlucHV0KSkge1xuICAgICAgICBjb25zdCB1cmwgPSBwYXJzZUFic29sdXRlVXJsKCdodHRwOicgKyBpbnB1dCk7XG4gICAgICAgIHVybC5zY2hlbWUgPSAnJztcbiAgICAgICAgdXJsLnR5cGUgPSA2IC8qIFNjaGVtZVJlbGF0aXZlICovO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBpZiAoaXNBYnNvbHV0ZVBhdGgoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHBhcnNlQWJzb2x1dGVVcmwoJ2h0dHA6Ly9mb28uY29tJyArIGlucHV0KTtcbiAgICAgICAgdXJsLnNjaGVtZSA9ICcnO1xuICAgICAgICB1cmwuaG9zdCA9ICcnO1xuICAgICAgICB1cmwudHlwZSA9IDUgLyogQWJzb2x1dGVQYXRoICovO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBpZiAoaXNGaWxlVXJsKGlucHV0KSlcbiAgICAgICAgcmV0dXJuIHBhcnNlRmlsZVVybChpbnB1dCk7XG4gICAgaWYgKGlzQWJzb2x1dGVVcmwoaW5wdXQpKVxuICAgICAgICByZXR1cm4gcGFyc2VBYnNvbHV0ZVVybChpbnB1dCk7XG4gICAgY29uc3QgdXJsID0gcGFyc2VBYnNvbHV0ZVVybCgnaHR0cDovL2Zvby5jb20vJyArIGlucHV0KTtcbiAgICB1cmwuc2NoZW1lID0gJyc7XG4gICAgdXJsLmhvc3QgPSAnJztcbiAgICB1cmwudHlwZSA9IGlucHV0XG4gICAgICAgID8gaW5wdXQuc3RhcnRzV2l0aCgnPycpXG4gICAgICAgICAgICA/IDMgLyogUXVlcnkgKi9cbiAgICAgICAgICAgIDogaW5wdXQuc3RhcnRzV2l0aCgnIycpXG4gICAgICAgICAgICAgICAgPyAyIC8qIEhhc2ggKi9cbiAgICAgICAgICAgICAgICA6IDQgLyogUmVsYXRpdmVQYXRoICovXG4gICAgICAgIDogMSAvKiBFbXB0eSAqLztcbiAgICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gc3RyaXBQYXRoRmlsZW5hbWUocGF0aCkge1xuICAgIC8vIElmIGEgcGF0aCBlbmRzIHdpdGggYSBwYXJlbnQgZGlyZWN0b3J5IFwiLi5cIiwgdGhlbiBpdCdzIGEgcmVsYXRpdmUgcGF0aCB3aXRoIGV4Y2VzcyBwYXJlbnRcbiAgICAvLyBwYXRocy4gSXQncyBub3QgYSBmaWxlLCBzbyB3ZSBjYW4ndCBzdHJpcCBpdC5cbiAgICBpZiAocGF0aC5lbmRzV2l0aCgnLy4uJykpXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIGNvbnN0IGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGluZGV4ICsgMSk7XG59XG5mdW5jdGlvbiBtZXJnZVBhdGhzKHVybCwgYmFzZSkge1xuICAgIG5vcm1hbGl6ZVBhdGgoYmFzZSwgYmFzZS50eXBlKTtcbiAgICAvLyBJZiB0aGUgcGF0aCBpcyBqdXN0IGEgXCIvXCIsIHRoZW4gaXQgd2FzIGFuIGVtcHR5IHBhdGggdG8gYmVnaW4gd2l0aCAocmVtZW1iZXIsIHdlJ3JlIGEgcmVsYXRpdmVcbiAgICAvLyBwYXRoKS5cbiAgICBpZiAodXJsLnBhdGggPT09ICcvJykge1xuICAgICAgICB1cmwucGF0aCA9IGJhc2UucGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFJlc29sdXRpb24gaGFwcGVucyByZWxhdGl2ZSB0byB0aGUgYmFzZSBwYXRoJ3MgZGlyZWN0b3J5LCBub3QgdGhlIGZpbGUuXG4gICAgICAgIHVybC5wYXRoID0gc3RyaXBQYXRoRmlsZW5hbWUoYmFzZS5wYXRoKSArIHVybC5wYXRoO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIHBhdGggY2FuIGhhdmUgZW1wdHkgZGlyZWN0b3JpZXMgXCIvL1wiLCB1bm5lZWRlZCBwYXJlbnRzIFwiZm9vLy4uXCIsIG9yIGN1cnJlbnQgZGlyZWN0b3J5XG4gKiBcImZvby8uXCIuIFdlIG5lZWQgdG8gbm9ybWFsaXplIHRvIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgodXJsLCB0eXBlKSB7XG4gICAgY29uc3QgcmVsID0gdHlwZSA8PSA0IC8qIFJlbGF0aXZlUGF0aCAqLztcbiAgICBjb25zdCBwaWVjZXMgPSB1cmwucGF0aC5zcGxpdCgnLycpO1xuICAgIC8vIFdlIG5lZWQgdG8gcHJlc2VydmUgdGhlIGZpcnN0IHBpZWNlIGFsd2F5cywgc28gdGhhdCB3ZSBvdXRwdXQgYSBsZWFkaW5nIHNsYXNoLiBUaGUgaXRlbSBhdFxuICAgIC8vIHBpZWNlc1swXSBpcyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgbGV0IHBvaW50ZXIgPSAxO1xuICAgIC8vIFBvc2l0aXZlIGlzIHRoZSBudW1iZXIgb2YgcmVhbCBkaXJlY3RvcmllcyB3ZSd2ZSBvdXRwdXQsIHVzZWQgZm9yIHBvcHBpbmcgYSBwYXJlbnQgZGlyZWN0b3J5LlxuICAgIC8vIEVnLCBcImZvby9iYXIvLi5cIiB3aWxsIGhhdmUgYSBwb3NpdGl2ZSAyLCBhbmQgd2UgY2FuIGRlY3JlbWVudCB0byBiZSBsZWZ0IHdpdGgganVzdCBcImZvb1wiLlxuICAgIGxldCBwb3NpdGl2ZSA9IDA7XG4gICAgLy8gV2UgbmVlZCB0byBrZWVwIGEgdHJhaWxpbmcgc2xhc2ggaWYgd2UgZW5jb3VudGVyIGFuIGVtcHR5IGRpcmVjdG9yeSAoZWcsIHNwbGl0dGluZyBcImZvby9cIiB3aWxsXG4gICAgLy8gZ2VuZXJhdGUgYFtcImZvb1wiLCBcIlwiXWAgcGllY2VzKS4gQW5kLCBpZiB3ZSBwb3AgYSBwYXJlbnQgZGlyZWN0b3J5LiBCdXQgb25jZSB3ZSBlbmNvdW50ZXIgYVxuICAgIC8vIHJlYWwgZGlyZWN0b3J5LCB3ZSB3b24ndCBuZWVkIHRvIGFwcGVuZCwgdW5sZXNzIHRoZSBvdGhlciBjb25kaXRpb25zIGhhcHBlbiBhZ2Fpbi5cbiAgICBsZXQgYWRkVHJhaWxpbmdTbGFzaCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBpZWNlID0gcGllY2VzW2ldO1xuICAgICAgICAvLyBBbiBlbXB0eSBkaXJlY3RvcnksIGNvdWxkIGJlIGEgdHJhaWxpbmcgc2xhc2gsIG9yIGp1c3QgYSBkb3VibGUgXCIvL1wiIGluIHRoZSBwYXRoLlxuICAgICAgICBpZiAoIXBpZWNlKSB7XG4gICAgICAgICAgICBhZGRUcmFpbGluZ1NsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhIHJlYWwgZGlyZWN0b3J5LCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gYXBwZW5kIGFueW1vcmUuXG4gICAgICAgIGFkZFRyYWlsaW5nU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgLy8gQSBjdXJyZW50IGRpcmVjdG9yeSwgd2hpY2ggd2UgY2FuIGFsd2F5cyBkcm9wLlxuICAgICAgICBpZiAocGllY2UgPT09ICcuJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAvLyBBIHBhcmVudCBkaXJlY3RvcnksIHdlIG5lZWQgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgcmVhbCBkaXJlY3RvcmllcyB3ZSBjYW4gcG9wLiBFbHNlLCB3ZVxuICAgICAgICAvLyBoYXZlIGFuIGV4Y2VzcyBvZiBwYXJlbnRzLCBhbmQgd2UnbGwgbmVlZCB0byBrZWVwIHRoZSBcIi4uXCIuXG4gICAgICAgIGlmIChwaWVjZSA9PT0gJy4uJykge1xuICAgICAgICAgICAgaWYgKHBvc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgYWRkVHJhaWxpbmdTbGFzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcG9zaXRpdmUtLTtcbiAgICAgICAgICAgICAgICBwb2ludGVyLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIHJlbGF0aXZlUGF0aCwgdGhlbiB3ZSBuZWVkIHRvIGtlZXAgdGhlIGV4Y2VzcyBwYXJlbnRzLiBFbHNlLCBpbiBhbiBhYnNvbHV0ZVxuICAgICAgICAgICAgICAgIC8vIFVSTCwgcHJvdG9jb2wgcmVsYXRpdmUgVVJMLCBvciBhbiBhYnNvbHV0ZSBwYXRoLCB3ZSBkb24ndCBuZWVkIHRvIGtlZXAgZXhjZXNzLlxuICAgICAgICAgICAgICAgIHBpZWNlc1twb2ludGVyKytdID0gcGllY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSd2ZSBlbmNvdW50ZXJlZCBhIHJlYWwgZGlyZWN0b3J5LiBNb3ZlIGl0IHRvIHRoZSBuZXh0IGluc2VydGlvbiBwb2ludGVyLCB3aGljaCBhY2NvdW50cyBmb3JcbiAgICAgICAgLy8gYW55IHBvcHBlZCBvciBkcm9wcGVkIGRpcmVjdG9yaWVzLlxuICAgICAgICBwaWVjZXNbcG9pbnRlcisrXSA9IHBpZWNlO1xuICAgICAgICBwb3NpdGl2ZSsrO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRlcjsgaSsrKSB7XG4gICAgICAgIHBhdGggKz0gJy8nICsgcGllY2VzW2ldO1xuICAgIH1cbiAgICBpZiAoIXBhdGggfHwgKGFkZFRyYWlsaW5nU2xhc2ggJiYgIXBhdGguZW5kc1dpdGgoJy8uLicpKSkge1xuICAgICAgICBwYXRoICs9ICcvJztcbiAgICB9XG4gICAgdXJsLnBhdGggPSBwYXRoO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXNvbHZlIGBpbnB1dGAgVVJML3BhdGggcmVsYXRpdmUgdG8gYGJhc2VgLlxuICovXG5mdW5jdGlvbiByZXNvbHZlKGlucHV0LCBiYXNlKSB7XG4gICAgaWYgKCFpbnB1dCAmJiAhYmFzZSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IHVybCA9IHBhcnNlVXJsKGlucHV0KTtcbiAgICBsZXQgaW5wdXRUeXBlID0gdXJsLnR5cGU7XG4gICAgaWYgKGJhc2UgJiYgaW5wdXRUeXBlICE9PSA3IC8qIEFic29sdXRlICovKSB7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBwYXJzZVVybChiYXNlKTtcbiAgICAgICAgY29uc3QgYmFzZVR5cGUgPSBiYXNlVXJsLnR5cGU7XG4gICAgICAgIHN3aXRjaCAoaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogRW1wdHkgKi86XG4gICAgICAgICAgICAgICAgdXJsLmhhc2ggPSBiYXNlVXJsLmhhc2g7XG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgMiAvKiBIYXNoICovOlxuICAgICAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2VVcmwucXVlcnk7XG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgMyAvKiBRdWVyeSAqLzpcbiAgICAgICAgICAgIGNhc2UgNCAvKiBSZWxhdGl2ZVBhdGggKi86XG4gICAgICAgICAgICAgICAgbWVyZ2VQYXRocyh1cmwsIGJhc2VVcmwpO1xuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIDUgLyogQWJzb2x1dGVQYXRoICovOlxuICAgICAgICAgICAgICAgIC8vIFRoZSBob3N0LCB1c2VyLCBhbmQgcG9ydCBhcmUgam9pbmVkLCB5b3UgY2FuJ3QgY29weSBvbmUgd2l0aG91dCB0aGUgb3RoZXJzLlxuICAgICAgICAgICAgICAgIHVybC51c2VyID0gYmFzZVVybC51c2VyO1xuICAgICAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZVVybC5ob3N0O1xuICAgICAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZVVybC5wb3J0O1xuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIDYgLyogU2NoZW1lUmVsYXRpdmUgKi86XG4gICAgICAgICAgICAgICAgLy8gVGhlIGlucHV0IGRvZXNuJ3QgaGF2ZSBhIHNjaGVtYSBhdCBsZWFzdCwgc28gd2UgbmVlZCB0byBjb3B5IGF0IGxlYXN0IHRoYXQgb3Zlci5cbiAgICAgICAgICAgICAgICB1cmwuc2NoZW1lID0gYmFzZVVybC5zY2hlbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID4gaW5wdXRUeXBlKVxuICAgICAgICAgICAgaW5wdXRUeXBlID0gYmFzZVR5cGU7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVBhdGgodXJsLCBpbnB1dFR5cGUpO1xuICAgIGNvbnN0IHF1ZXJ5SGFzaCA9IHVybC5xdWVyeSArIHVybC5oYXNoO1xuICAgIHN3aXRjaCAoaW5wdXRUeXBlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW1wb3NzaWJsZSwgYmVjYXVzZSBvZiB0aGUgZW1wdHkgY2hlY2tzIGF0IHRoZSBzdGFydCBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgIC8vIGNhc2UgVXJsVHlwZS5FbXB0eTpcbiAgICAgICAgY2FzZSAyIC8qIEhhc2ggKi86XG4gICAgICAgIGNhc2UgMyAvKiBRdWVyeSAqLzpcbiAgICAgICAgICAgIHJldHVybiBxdWVyeUhhc2g7XG4gICAgICAgIGNhc2UgNCAvKiBSZWxhdGl2ZVBhdGggKi86IHtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBjaGFyIGlzIGFsd2F5cyBhIFwiL1wiLCBhbmQgd2UgbmVlZCBpdCB0byBiZSByZWxhdGl2ZS5cbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSB1cmwucGF0aC5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmICghcGF0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlIYXNoIHx8ICcuJztcbiAgICAgICAgICAgIGlmIChpc1JlbGF0aXZlKGJhc2UgfHwgaW5wdXQpICYmICFpc1JlbGF0aXZlKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYmFzZSBzdGFydGVkIHdpdGggYSBsZWFkaW5nIFwiLlwiLCBvciB0aGVyZSBpcyBubyBiYXNlIGFuZCBpbnB1dCBzdGFydGVkIHdpdGggYSBcIi5cIixcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHJlbGF0aXZlIHBhdGggc3RhcnRzIHdpdGggYSBcIi5cIi4gV2UgZG9uJ3Qga25vdyBpZlxuICAgICAgICAgICAgICAgIC8vIHJlbGF0aXZlIHN0YXJ0cyB3aXRoIGEgXCIuLlwiLCB0aG91Z2gsIHNvIGNoZWNrIGJlZm9yZSBwcmVwZW5kaW5nLlxuICAgICAgICAgICAgICAgIHJldHVybiAnLi8nICsgcGF0aCArIHF1ZXJ5SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoICsgcXVlcnlIYXNoO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNSAvKiBBYnNvbHV0ZVBhdGggKi86XG4gICAgICAgICAgICByZXR1cm4gdXJsLnBhdGggKyBxdWVyeUhhc2g7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdXJsLnNjaGVtZSArICcvLycgKyB1cmwudXNlciArIHVybC5ob3N0ICsgdXJsLnBvcnQgKyB1cmwucGF0aCArIHF1ZXJ5SGFzaDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IHJlc29sdmUgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZS11cmkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   decodeGeneratedRanges: () => (/* binding */ decodeGeneratedRanges),\n/* harmony export */   decodeOriginalScopes: () => (/* binding */ decodeOriginalScopes),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeGeneratedRanges: () => (/* binding */ encodeGeneratedRanges),\n/* harmony export */   encodeOriginalScopes: () => (/* binding */ encodeOriginalScopes)\n/* harmony export */ });\n// src/vlq.ts\nvar comma = \",\".charCodeAt(0);\nvar semicolon = \";\".charCodeAt(0);\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar intToChar = new Uint8Array(64);\nvar charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nfunction decodeInteger(reader, relative) {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n  const shouldNegate = value & 1;\n  value >>>= 1;\n  if (shouldNegate) {\n    value = -2147483648 | -value;\n  }\n  return relative + value;\n}\nfunction encodeInteger(builder, num, relative) {\n  let delta = num - relative;\n  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;\n  do {\n    let clamped = delta & 31;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 32;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n  return num;\n}\nfunction hasMoreVlq(reader, max) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n\n// src/strings.ts\nvar bufLength = 1024 * 16;\nvar td = typeof TextDecoder !== \"undefined\" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== \"undefined\" ? {\n  decode(buf) {\n    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n    return out.toString();\n  }\n} : {\n  decode(buf) {\n    let out = \"\";\n    for (let i = 0; i < buf.length; i++) {\n      out += String.fromCharCode(buf[i]);\n    }\n    return out;\n  }\n};\nvar StringWriter = class {\n  constructor() {\n    this.pos = 0;\n    this.out = \"\";\n    this.buffer = new Uint8Array(bufLength);\n  }\n  write(v) {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n  flush() {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n};\nvar StringReader = class {\n  constructor(buffer) {\n    this.pos = 0;\n    this.buffer = buffer;\n  }\n  next() {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n  peek() {\n    return this.buffer.charCodeAt(this.pos);\n  }\n  indexOf(char) {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n};\n\n// src/scopes.ts\nvar EMPTY = [];\nfunction decodeOriginalScopes(input) {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes = [];\n  const stack = [];\n  let line = 0;\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop();\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 1;\n    const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];\n    let vars = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n    scopes.push(scope);\n    stack.push(scope);\n  }\n  return scopes;\n}\nfunction encodeOriginalScopes(scopes) {\n  const writer = new StringWriter();\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n  return writer.flush();\n}\nfunction _encodeOriginalScopes(scopes, index, writer, state) {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n  if (index > 0) writer.write(comma);\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n  const fields = scope.length === 6 ? 1 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || l === endLine && c >= endColumn) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n  return index;\n}\nfunction decodeGeneratedRanges(input) {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges = [];\n  const stack = [];\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    let genColumn = 0;\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop();\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 1;\n      const hasCallsite = fields & 2;\n      const hasScope = fields & 4;\n      let callsite = null;\n      let bindings = EMPTY;\n      let range;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0\n        );\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];\n      } else {\n        range = [genLine, genColumn, 0, 0];\n      }\n      range.isScope = !!hasScope;\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0\n        );\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges;\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n      ranges.push(range);\n      stack.push(range);\n    }\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n  return ranges;\n}\nfunction encodeGeneratedRanges(ranges) {\n  if (ranges.length === 0) return \"\";\n  const writer = new StringWriter();\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n  return writer.flush();\n}\nfunction _encodeGeneratedRanges(ranges, index, writer, state) {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings\n  } = range;\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, range[1], state[1]);\n  const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);\n  encodeInteger(writer, fields, 0);\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);\n        encodeInteger(writer, expRange[0], 0);\n      }\n    }\n  }\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || l === endLine && c >= endColumn) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n  return index;\n}\nfunction catchupLine(writer, lastLine, line) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n\n// src/sourcemap-codec.ts\nfunction decode(mappings) {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    const line = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n    while (reader.pos < semi) {\n      let seg;\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n      line.push(seg);\n      reader.pos++;\n    }\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n  return decoded;\n}\nfunction sort(line) {\n  line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[0] - b[0];\n}\nfunction encode(decoded) {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n    let genColumn = 0;\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n  return writer.flush();\n}\n\n//# sourceMappingURL=sourcemap-codec.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvc291cmNlbWFwLWNvZGVjL2Rpc3Qvc291cmNlbWFwLWNvZGVjLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQkFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3RUFBd0U7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtDQUFrQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWxpYnJhcnktZG9jcy8uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWMvZGlzdC9zb3VyY2VtYXAtY29kZWMubWpzP2E0YmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3ZscS50c1xudmFyIGNvbW1hID0gXCIsXCIuY2hhckNvZGVBdCgwKTtcbnZhciBzZW1pY29sb24gPSBcIjtcIi5jaGFyQ29kZUF0KDApO1xudmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG52YXIgaW50VG9DaGFyID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xudmFyIGNoYXJUb0ludCA9IG5ldyBVaW50OEFycmF5KDEyOCk7XG5mb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IGMgPSBjaGFycy5jaGFyQ29kZUF0KGkpO1xuICBpbnRUb0NoYXJbaV0gPSBjO1xuICBjaGFyVG9JbnRbY10gPSBpO1xufVxuZnVuY3Rpb24gZGVjb2RlSW50ZWdlcihyZWFkZXIsIHJlbGF0aXZlKSB7XG4gIGxldCB2YWx1ZSA9IDA7XG4gIGxldCBzaGlmdCA9IDA7XG4gIGxldCBpbnRlZ2VyID0gMDtcbiAgZG8ge1xuICAgIGNvbnN0IGMgPSByZWFkZXIubmV4dCgpO1xuICAgIGludGVnZXIgPSBjaGFyVG9JbnRbY107XG4gICAgdmFsdWUgfD0gKGludGVnZXIgJiAzMSkgPDwgc2hpZnQ7XG4gICAgc2hpZnQgKz0gNTtcbiAgfSB3aGlsZSAoaW50ZWdlciAmIDMyKTtcbiAgY29uc3Qgc2hvdWxkTmVnYXRlID0gdmFsdWUgJiAxO1xuICB2YWx1ZSA+Pj49IDE7XG4gIGlmIChzaG91bGROZWdhdGUpIHtcbiAgICB2YWx1ZSA9IC0yMTQ3NDgzNjQ4IHwgLXZhbHVlO1xuICB9XG4gIHJldHVybiByZWxhdGl2ZSArIHZhbHVlO1xufVxuZnVuY3Rpb24gZW5jb2RlSW50ZWdlcihidWlsZGVyLCBudW0sIHJlbGF0aXZlKSB7XG4gIGxldCBkZWx0YSA9IG51bSAtIHJlbGF0aXZlO1xuICBkZWx0YSA9IGRlbHRhIDwgMCA/IC1kZWx0YSA8PCAxIHwgMSA6IGRlbHRhIDw8IDE7XG4gIGRvIHtcbiAgICBsZXQgY2xhbXBlZCA9IGRlbHRhICYgMzE7XG4gICAgZGVsdGEgPj4+PSA1O1xuICAgIGlmIChkZWx0YSA+IDApIGNsYW1wZWQgfD0gMzI7XG4gICAgYnVpbGRlci53cml0ZShpbnRUb0NoYXJbY2xhbXBlZF0pO1xuICB9IHdoaWxlIChkZWx0YSA+IDApO1xuICByZXR1cm4gbnVtO1xufVxuZnVuY3Rpb24gaGFzTW9yZVZscShyZWFkZXIsIG1heCkge1xuICBpZiAocmVhZGVyLnBvcyA+PSBtYXgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHJlYWRlci5wZWVrKCkgIT09IGNvbW1hO1xufVxuXG4vLyBzcmMvc3RyaW5ncy50c1xudmFyIGJ1Zkxlbmd0aCA9IDEwMjQgKiAxNjtcbnZhciB0ZCA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gXCJ1bmRlZmluZWRcIiA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgVGV4dERlY29kZXIoKSA6IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgPyB7XG4gIGRlY29kZShidWYpIHtcbiAgICBjb25zdCBvdXQgPSBCdWZmZXIuZnJvbShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiBvdXQudG9TdHJpbmcoKTtcbiAgfVxufSA6IHtcbiAgZGVjb2RlKGJ1Zikge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG59O1xudmFyIFN0cmluZ1dyaXRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMub3V0ID0gXCJcIjtcbiAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1Zkxlbmd0aCk7XG4gIH1cbiAgd3JpdGUodikge1xuICAgIGNvbnN0IHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgIGJ1ZmZlclt0aGlzLnBvcysrXSA9IHY7XG4gICAgaWYgKHRoaXMucG9zID09PSBidWZMZW5ndGgpIHtcbiAgICAgIHRoaXMub3V0ICs9IHRkLmRlY29kZShidWZmZXIpO1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCB7IGJ1ZmZlciwgb3V0LCBwb3MgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHBvcyA+IDAgPyBvdXQgKyB0ZC5kZWNvZGUoYnVmZmVyLnN1YmFycmF5KDAsIHBvcykpIDogb3V0O1xuICB9XG59O1xudmFyIFN0cmluZ1JlYWRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICB9XG4gIG5leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5wb3MrKyk7XG4gIH1cbiAgcGVlaygpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIH1cbiAgaW5kZXhPZihjaGFyKSB7XG4gICAgY29uc3QgeyBidWZmZXIsIHBvcyB9ID0gdGhpcztcbiAgICBjb25zdCBpZHggPSBidWZmZXIuaW5kZXhPZihjaGFyLCBwb3MpO1xuICAgIHJldHVybiBpZHggPT09IC0xID8gYnVmZmVyLmxlbmd0aCA6IGlkeDtcbiAgfVxufTtcblxuLy8gc3JjL3Njb3Blcy50c1xudmFyIEVNUFRZID0gW107XG5mdW5jdGlvbiBkZWNvZGVPcmlnaW5hbFNjb3BlcyhpbnB1dCkge1xuICBjb25zdCB7IGxlbmd0aCB9ID0gaW5wdXQ7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBTdHJpbmdSZWFkZXIoaW5wdXQpO1xuICBjb25zdCBzY29wZXMgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgbGV0IGxpbmUgPSAwO1xuICBmb3IgKDsgcmVhZGVyLnBvcyA8IGxlbmd0aDsgcmVhZGVyLnBvcysrKSB7XG4gICAgbGluZSA9IGRlY29kZUludGVnZXIocmVhZGVyLCBsaW5lKTtcbiAgICBjb25zdCBjb2x1bW4gPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgaWYgKCFoYXNNb3JlVmxxKHJlYWRlciwgbGVuZ3RoKSkge1xuICAgICAgY29uc3QgbGFzdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgbGFzdFsyXSA9IGxpbmU7XG4gICAgICBsYXN0WzNdID0gY29sdW1uO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGtpbmQgPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgY29uc3QgZmllbGRzID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIDApO1xuICAgIGNvbnN0IGhhc05hbWUgPSBmaWVsZHMgJiAxO1xuICAgIGNvbnN0IHNjb3BlID0gaGFzTmFtZSA/IFtsaW5lLCBjb2x1bW4sIDAsIDAsIGtpbmQsIGRlY29kZUludGVnZXIocmVhZGVyLCAwKV0gOiBbbGluZSwgY29sdW1uLCAwLCAwLCBraW5kXTtcbiAgICBsZXQgdmFycyA9IEVNUFRZO1xuICAgIGlmIChoYXNNb3JlVmxxKHJlYWRlciwgbGVuZ3RoKSkge1xuICAgICAgdmFycyA9IFtdO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCB2YXJzSW5kZXggPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgICAgIHZhcnMucHVzaCh2YXJzSW5kZXgpO1xuICAgICAgfSB3aGlsZSAoaGFzTW9yZVZscShyZWFkZXIsIGxlbmd0aCkpO1xuICAgIH1cbiAgICBzY29wZS52YXJzID0gdmFycztcbiAgICBzY29wZXMucHVzaChzY29wZSk7XG4gICAgc3RhY2sucHVzaChzY29wZSk7XG4gIH1cbiAgcmV0dXJuIHNjb3Blcztcbn1cbmZ1bmN0aW9uIGVuY29kZU9yaWdpbmFsU2NvcGVzKHNjb3Blcykge1xuICBjb25zdCB3cml0ZXIgPSBuZXcgU3RyaW5nV3JpdGVyKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2NvcGVzLmxlbmd0aDsgKSB7XG4gICAgaSA9IF9lbmNvZGVPcmlnaW5hbFNjb3BlcyhzY29wZXMsIGksIHdyaXRlciwgWzBdKTtcbiAgfVxuICByZXR1cm4gd3JpdGVyLmZsdXNoKCk7XG59XG5mdW5jdGlvbiBfZW5jb2RlT3JpZ2luYWxTY29wZXMoc2NvcGVzLCBpbmRleCwgd3JpdGVyLCBzdGF0ZSkge1xuICBjb25zdCBzY29wZSA9IHNjb3Blc1tpbmRleF07XG4gIGNvbnN0IHsgMDogc3RhcnRMaW5lLCAxOiBzdGFydENvbHVtbiwgMjogZW5kTGluZSwgMzogZW5kQ29sdW1uLCA0OiBraW5kLCB2YXJzIH0gPSBzY29wZTtcbiAgaWYgKGluZGV4ID4gMCkgd3JpdGVyLndyaXRlKGNvbW1hKTtcbiAgc3RhdGVbMF0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc3RhcnRMaW5lLCBzdGF0ZVswXSk7XG4gIGVuY29kZUludGVnZXIod3JpdGVyLCBzdGFydENvbHVtbiwgMCk7XG4gIGVuY29kZUludGVnZXIod3JpdGVyLCBraW5kLCAwKTtcbiAgY29uc3QgZmllbGRzID0gc2NvcGUubGVuZ3RoID09PSA2ID8gMSA6IDA7XG4gIGVuY29kZUludGVnZXIod3JpdGVyLCBmaWVsZHMsIDApO1xuICBpZiAoc2NvcGUubGVuZ3RoID09PSA2KSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc2NvcGVbNV0sIDApO1xuICBmb3IgKGNvbnN0IHYgb2YgdmFycykge1xuICAgIGVuY29kZUludGVnZXIod3JpdGVyLCB2LCAwKTtcbiAgfVxuICBmb3IgKGluZGV4Kys7IGluZGV4IDwgc2NvcGVzLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgbmV4dCA9IHNjb3Blc1tpbmRleF07XG4gICAgY29uc3QgeyAwOiBsLCAxOiBjIH0gPSBuZXh0O1xuICAgIGlmIChsID4gZW5kTGluZSB8fCBsID09PSBlbmRMaW5lICYmIGMgPj0gZW5kQ29sdW1uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXggPSBfZW5jb2RlT3JpZ2luYWxTY29wZXMoc2NvcGVzLCBpbmRleCwgd3JpdGVyLCBzdGF0ZSk7XG4gIH1cbiAgd3JpdGVyLndyaXRlKGNvbW1hKTtcbiAgc3RhdGVbMF0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZW5kTGluZSwgc3RhdGVbMF0pO1xuICBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZW5kQ29sdW1uLCAwKTtcbiAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gZGVjb2RlR2VuZXJhdGVkUmFuZ2VzKGlucHV0KSB7XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBpbnB1dDtcbiAgY29uc3QgcmVhZGVyID0gbmV3IFN0cmluZ1JlYWRlcihpbnB1dCk7XG4gIGNvbnN0IHJhbmdlcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBsZXQgZ2VuTGluZSA9IDA7XG4gIGxldCBkZWZpbml0aW9uU291cmNlc0luZGV4ID0gMDtcbiAgbGV0IGRlZmluaXRpb25TY29wZUluZGV4ID0gMDtcbiAgbGV0IGNhbGxzaXRlU291cmNlc0luZGV4ID0gMDtcbiAgbGV0IGNhbGxzaXRlTGluZSA9IDA7XG4gIGxldCBjYWxsc2l0ZUNvbHVtbiA9IDA7XG4gIGxldCBiaW5kaW5nTGluZSA9IDA7XG4gIGxldCBiaW5kaW5nQ29sdW1uID0gMDtcbiAgZG8ge1xuICAgIGNvbnN0IHNlbWkgPSByZWFkZXIuaW5kZXhPZihcIjtcIik7XG4gICAgbGV0IGdlbkNvbHVtbiA9IDA7XG4gICAgZm9yICg7IHJlYWRlci5wb3MgPCBzZW1pOyByZWFkZXIucG9zKyspIHtcbiAgICAgIGdlbkNvbHVtbiA9IGRlY29kZUludGVnZXIocmVhZGVyLCBnZW5Db2x1bW4pO1xuICAgICAgaWYgKCFoYXNNb3JlVmxxKHJlYWRlciwgc2VtaSkpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBsYXN0WzJdID0gZ2VuTGluZTtcbiAgICAgICAgbGFzdFszXSA9IGdlbkNvbHVtbjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBmaWVsZHMgPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgICBjb25zdCBoYXNEZWZpbml0aW9uID0gZmllbGRzICYgMTtcbiAgICAgIGNvbnN0IGhhc0NhbGxzaXRlID0gZmllbGRzICYgMjtcbiAgICAgIGNvbnN0IGhhc1Njb3BlID0gZmllbGRzICYgNDtcbiAgICAgIGxldCBjYWxsc2l0ZSA9IG51bGw7XG4gICAgICBsZXQgYmluZGluZ3MgPSBFTVBUWTtcbiAgICAgIGxldCByYW5nZTtcbiAgICAgIGlmIChoYXNEZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IGRlZlNvdXJjZXNJbmRleCA9IGRlY29kZUludGVnZXIocmVhZGVyLCBkZWZpbml0aW9uU291cmNlc0luZGV4KTtcbiAgICAgICAgZGVmaW5pdGlvblNjb3BlSW5kZXggPSBkZWNvZGVJbnRlZ2VyKFxuICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICBkZWZpbml0aW9uU291cmNlc0luZGV4ID09PSBkZWZTb3VyY2VzSW5kZXggPyBkZWZpbml0aW9uU2NvcGVJbmRleCA6IDBcbiAgICAgICAgKTtcbiAgICAgICAgZGVmaW5pdGlvblNvdXJjZXNJbmRleCA9IGRlZlNvdXJjZXNJbmRleDtcbiAgICAgICAgcmFuZ2UgPSBbZ2VuTGluZSwgZ2VuQ29sdW1uLCAwLCAwLCBkZWZTb3VyY2VzSW5kZXgsIGRlZmluaXRpb25TY29wZUluZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gW2dlbkxpbmUsIGdlbkNvbHVtbiwgMCwgMF07XG4gICAgICB9XG4gICAgICByYW5nZS5pc1Njb3BlID0gISFoYXNTY29wZTtcbiAgICAgIGlmIChoYXNDYWxsc2l0ZSkge1xuICAgICAgICBjb25zdCBwcmV2Q3NpID0gY2FsbHNpdGVTb3VyY2VzSW5kZXg7XG4gICAgICAgIGNvbnN0IHByZXZMaW5lID0gY2FsbHNpdGVMaW5lO1xuICAgICAgICBjYWxsc2l0ZVNvdXJjZXNJbmRleCA9IGRlY29kZUludGVnZXIocmVhZGVyLCBjYWxsc2l0ZVNvdXJjZXNJbmRleCk7XG4gICAgICAgIGNvbnN0IHNhbWVTb3VyY2UgPSBwcmV2Q3NpID09PSBjYWxsc2l0ZVNvdXJjZXNJbmRleDtcbiAgICAgICAgY2FsbHNpdGVMaW5lID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIHNhbWVTb3VyY2UgPyBjYWxsc2l0ZUxpbmUgOiAwKTtcbiAgICAgICAgY2FsbHNpdGVDb2x1bW4gPSBkZWNvZGVJbnRlZ2VyKFxuICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICBzYW1lU291cmNlICYmIHByZXZMaW5lID09PSBjYWxsc2l0ZUxpbmUgPyBjYWxsc2l0ZUNvbHVtbiA6IDBcbiAgICAgICAgKTtcbiAgICAgICAgY2FsbHNpdGUgPSBbY2FsbHNpdGVTb3VyY2VzSW5kZXgsIGNhbGxzaXRlTGluZSwgY2FsbHNpdGVDb2x1bW5dO1xuICAgICAgfVxuICAgICAgcmFuZ2UuY2FsbHNpdGUgPSBjYWxsc2l0ZTtcbiAgICAgIGlmIChoYXNNb3JlVmxxKHJlYWRlciwgc2VtaSkpIHtcbiAgICAgICAgYmluZGluZ3MgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGJpbmRpbmdMaW5lID0gZ2VuTGluZTtcbiAgICAgICAgICBiaW5kaW5nQ29sdW1uID0gZ2VuQ29sdW1uO1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25zQ291bnQgPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgICAgICAgbGV0IGV4cHJlc3Npb25SYW5nZXM7XG4gICAgICAgICAgaWYgKGV4cHJlc3Npb25zQ291bnQgPCAtMSkge1xuICAgICAgICAgICAgZXhwcmVzc2lvblJhbmdlcyA9IFtbZGVjb2RlSW50ZWdlcihyZWFkZXIsIDApXV07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gLTE7IGkgPiBleHByZXNzaW9uc0NvdW50OyBpLS0pIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJldkJsID0gYmluZGluZ0xpbmU7XG4gICAgICAgICAgICAgIGJpbmRpbmdMaW5lID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIGJpbmRpbmdMaW5lKTtcbiAgICAgICAgICAgICAgYmluZGluZ0NvbHVtbiA9IGRlY29kZUludGVnZXIocmVhZGVyLCBiaW5kaW5nTGluZSA9PT0gcHJldkJsID8gYmluZGluZ0NvbHVtbiA6IDApO1xuICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIDApO1xuICAgICAgICAgICAgICBleHByZXNzaW9uUmFuZ2VzLnB1c2goW2V4cHJlc3Npb24sIGJpbmRpbmdMaW5lLCBiaW5kaW5nQ29sdW1uXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25SYW5nZXMgPSBbW2V4cHJlc3Npb25zQ291bnRdXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYmluZGluZ3MucHVzaChleHByZXNzaW9uUmFuZ2VzKTtcbiAgICAgICAgfSB3aGlsZSAoaGFzTW9yZVZscShyZWFkZXIsIHNlbWkpKTtcbiAgICAgIH1cbiAgICAgIHJhbmdlLmJpbmRpbmdzID0gYmluZGluZ3M7XG4gICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICBzdGFjay5wdXNoKHJhbmdlKTtcbiAgICB9XG4gICAgZ2VuTGluZSsrO1xuICAgIHJlYWRlci5wb3MgPSBzZW1pICsgMTtcbiAgfSB3aGlsZSAocmVhZGVyLnBvcyA8IGxlbmd0aCk7XG4gIHJldHVybiByYW5nZXM7XG59XG5mdW5jdGlvbiBlbmNvZGVHZW5lcmF0ZWRSYW5nZXMocmFuZ2VzKSB7XG4gIGlmIChyYW5nZXMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJcIjtcbiAgY29uc3Qgd3JpdGVyID0gbmV3IFN0cmluZ1dyaXRlcigpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7ICkge1xuICAgIGkgPSBfZW5jb2RlR2VuZXJhdGVkUmFuZ2VzKHJhbmdlcywgaSwgd3JpdGVyLCBbMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICB9XG4gIHJldHVybiB3cml0ZXIuZmx1c2goKTtcbn1cbmZ1bmN0aW9uIF9lbmNvZGVHZW5lcmF0ZWRSYW5nZXMocmFuZ2VzLCBpbmRleCwgd3JpdGVyLCBzdGF0ZSkge1xuICBjb25zdCByYW5nZSA9IHJhbmdlc1tpbmRleF07XG4gIGNvbnN0IHtcbiAgICAwOiBzdGFydExpbmUsXG4gICAgMTogc3RhcnRDb2x1bW4sXG4gICAgMjogZW5kTGluZSxcbiAgICAzOiBlbmRDb2x1bW4sXG4gICAgaXNTY29wZSxcbiAgICBjYWxsc2l0ZSxcbiAgICBiaW5kaW5nc1xuICB9ID0gcmFuZ2U7XG4gIGlmIChzdGF0ZVswXSA8IHN0YXJ0TGluZSkge1xuICAgIGNhdGNodXBMaW5lKHdyaXRlciwgc3RhdGVbMF0sIHN0YXJ0TGluZSk7XG4gICAgc3RhdGVbMF0gPSBzdGFydExpbmU7XG4gICAgc3RhdGVbMV0gPSAwO1xuICB9IGVsc2UgaWYgKGluZGV4ID4gMCkge1xuICAgIHdyaXRlci53cml0ZShjb21tYSk7XG4gIH1cbiAgc3RhdGVbMV0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgcmFuZ2VbMV0sIHN0YXRlWzFdKTtcbiAgY29uc3QgZmllbGRzID0gKHJhbmdlLmxlbmd0aCA9PT0gNiA/IDEgOiAwKSB8IChjYWxsc2l0ZSA/IDIgOiAwKSB8IChpc1Njb3BlID8gNCA6IDApO1xuICBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZmllbGRzLCAwKTtcbiAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gNikge1xuICAgIGNvbnN0IHsgNDogc291cmNlc0luZGV4LCA1OiBzY29wZXNJbmRleCB9ID0gcmFuZ2U7XG4gICAgaWYgKHNvdXJjZXNJbmRleCAhPT0gc3RhdGVbMl0pIHtcbiAgICAgIHN0YXRlWzNdID0gMDtcbiAgICB9XG4gICAgc3RhdGVbMl0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc291cmNlc0luZGV4LCBzdGF0ZVsyXSk7XG4gICAgc3RhdGVbM10gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc2NvcGVzSW5kZXgsIHN0YXRlWzNdKTtcbiAgfVxuICBpZiAoY2FsbHNpdGUpIHtcbiAgICBjb25zdCB7IDA6IHNvdXJjZXNJbmRleCwgMTogY2FsbExpbmUsIDI6IGNhbGxDb2x1bW4gfSA9IHJhbmdlLmNhbGxzaXRlO1xuICAgIGlmIChzb3VyY2VzSW5kZXggIT09IHN0YXRlWzRdKSB7XG4gICAgICBzdGF0ZVs1XSA9IDA7XG4gICAgICBzdGF0ZVs2XSA9IDA7XG4gICAgfSBlbHNlIGlmIChjYWxsTGluZSAhPT0gc3RhdGVbNV0pIHtcbiAgICAgIHN0YXRlWzZdID0gMDtcbiAgICB9XG4gICAgc3RhdGVbNF0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc291cmNlc0luZGV4LCBzdGF0ZVs0XSk7XG4gICAgc3RhdGVbNV0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgY2FsbExpbmUsIHN0YXRlWzVdKTtcbiAgICBzdGF0ZVs2XSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBjYWxsQ29sdW1uLCBzdGF0ZVs2XSk7XG4gIH1cbiAgaWYgKGJpbmRpbmdzKSB7XG4gICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIGJpbmRpbmdzKSB7XG4gICAgICBpZiAoYmluZGluZy5sZW5ndGggPiAxKSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgLWJpbmRpbmcubGVuZ3RoLCAwKTtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBiaW5kaW5nWzBdWzBdO1xuICAgICAgZW5jb2RlSW50ZWdlcih3cml0ZXIsIGV4cHJlc3Npb24sIDApO1xuICAgICAgbGV0IGJpbmRpbmdTdGFydExpbmUgPSBzdGFydExpbmU7XG4gICAgICBsZXQgYmluZGluZ1N0YXJ0Q29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGJpbmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZXhwUmFuZ2UgPSBiaW5kaW5nW2ldO1xuICAgICAgICBiaW5kaW5nU3RhcnRMaW5lID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIGV4cFJhbmdlWzFdLCBiaW5kaW5nU3RhcnRMaW5lKTtcbiAgICAgICAgYmluZGluZ1N0YXJ0Q29sdW1uID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIGV4cFJhbmdlWzJdLCBiaW5kaW5nU3RhcnRDb2x1bW4pO1xuICAgICAgICBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZXhwUmFuZ2VbMF0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGluZGV4Kys7IGluZGV4IDwgcmFuZ2VzLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgbmV4dCA9IHJhbmdlc1tpbmRleF07XG4gICAgY29uc3QgeyAwOiBsLCAxOiBjIH0gPSBuZXh0O1xuICAgIGlmIChsID4gZW5kTGluZSB8fCBsID09PSBlbmRMaW5lICYmIGMgPj0gZW5kQ29sdW1uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXggPSBfZW5jb2RlR2VuZXJhdGVkUmFuZ2VzKHJhbmdlcywgaW5kZXgsIHdyaXRlciwgc3RhdGUpO1xuICB9XG4gIGlmIChzdGF0ZVswXSA8IGVuZExpbmUpIHtcbiAgICBjYXRjaHVwTGluZSh3cml0ZXIsIHN0YXRlWzBdLCBlbmRMaW5lKTtcbiAgICBzdGF0ZVswXSA9IGVuZExpbmU7XG4gICAgc3RhdGVbMV0gPSAwO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlci53cml0ZShjb21tYSk7XG4gIH1cbiAgc3RhdGVbMV0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZW5kQ29sdW1uLCBzdGF0ZVsxXSk7XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGNhdGNodXBMaW5lKHdyaXRlciwgbGFzdExpbmUsIGxpbmUpIHtcbiAgZG8ge1xuICAgIHdyaXRlci53cml0ZShzZW1pY29sb24pO1xuICB9IHdoaWxlICgrK2xhc3RMaW5lIDwgbGluZSk7XG59XG5cbi8vIHNyYy9zb3VyY2VtYXAtY29kZWMudHNcbmZ1bmN0aW9uIGRlY29kZShtYXBwaW5ncykge1xuICBjb25zdCB7IGxlbmd0aCB9ID0gbWFwcGluZ3M7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBTdHJpbmdSZWFkZXIobWFwcGluZ3MpO1xuICBjb25zdCBkZWNvZGVkID0gW107XG4gIGxldCBnZW5Db2x1bW4gPSAwO1xuICBsZXQgc291cmNlc0luZGV4ID0gMDtcbiAgbGV0IHNvdXJjZUxpbmUgPSAwO1xuICBsZXQgc291cmNlQ29sdW1uID0gMDtcbiAgbGV0IG5hbWVzSW5kZXggPSAwO1xuICBkbyB7XG4gICAgY29uc3Qgc2VtaSA9IHJlYWRlci5pbmRleE9mKFwiO1wiKTtcbiAgICBjb25zdCBsaW5lID0gW107XG4gICAgbGV0IHNvcnRlZCA9IHRydWU7XG4gICAgbGV0IGxhc3RDb2wgPSAwO1xuICAgIGdlbkNvbHVtbiA9IDA7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBzZW1pKSB7XG4gICAgICBsZXQgc2VnO1xuICAgICAgZ2VuQ29sdW1uID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIGdlbkNvbHVtbik7XG4gICAgICBpZiAoZ2VuQ29sdW1uIDwgbGFzdENvbCkgc29ydGVkID0gZmFsc2U7XG4gICAgICBsYXN0Q29sID0gZ2VuQ29sdW1uO1xuICAgICAgaWYgKGhhc01vcmVWbHEocmVhZGVyLCBzZW1pKSkge1xuICAgICAgICBzb3VyY2VzSW5kZXggPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgc291cmNlc0luZGV4KTtcbiAgICAgICAgc291cmNlTGluZSA9IGRlY29kZUludGVnZXIocmVhZGVyLCBzb3VyY2VMaW5lKTtcbiAgICAgICAgc291cmNlQ29sdW1uID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIHNvdXJjZUNvbHVtbik7XG4gICAgICAgIGlmIChoYXNNb3JlVmxxKHJlYWRlciwgc2VtaSkpIHtcbiAgICAgICAgICBuYW1lc0luZGV4ID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIG5hbWVzSW5kZXgpO1xuICAgICAgICAgIHNlZyA9IFtnZW5Db2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lc0luZGV4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWcgPSBbZ2VuQ29sdW1uLCBzb3VyY2VzSW5kZXgsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbl07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZyA9IFtnZW5Db2x1bW5dO1xuICAgICAgfVxuICAgICAgbGluZS5wdXNoKHNlZyk7XG4gICAgICByZWFkZXIucG9zKys7XG4gICAgfVxuICAgIGlmICghc29ydGVkKSBzb3J0KGxpbmUpO1xuICAgIGRlY29kZWQucHVzaChsaW5lKTtcbiAgICByZWFkZXIucG9zID0gc2VtaSArIDE7XG4gIH0gd2hpbGUgKHJlYWRlci5wb3MgPD0gbGVuZ3RoKTtcbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5mdW5jdGlvbiBzb3J0KGxpbmUpIHtcbiAgbGluZS5zb3J0KHNvcnRDb21wYXJhdG9yKTtcbn1cbmZ1bmN0aW9uIHNvcnRDb21wYXJhdG9yKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdO1xufVxuZnVuY3Rpb24gZW5jb2RlKGRlY29kZWQpIHtcbiAgY29uc3Qgd3JpdGVyID0gbmV3IFN0cmluZ1dyaXRlcigpO1xuICBsZXQgc291cmNlc0luZGV4ID0gMDtcbiAgbGV0IHNvdXJjZUxpbmUgPSAwO1xuICBsZXQgc291cmNlQ29sdW1uID0gMDtcbiAgbGV0IG5hbWVzSW5kZXggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gZGVjb2RlZFtpXTtcbiAgICBpZiAoaSA+IDApIHdyaXRlci53cml0ZShzZW1pY29sb24pO1xuICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgbGV0IGdlbkNvbHVtbiA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBzZWdtZW50ID0gbGluZVtqXTtcbiAgICAgIGlmIChqID4gMCkgd3JpdGVyLndyaXRlKGNvbW1hKTtcbiAgICAgIGdlbkNvbHVtbiA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzBdLCBnZW5Db2x1bW4pO1xuICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAxKSBjb250aW51ZTtcbiAgICAgIHNvdXJjZXNJbmRleCA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzFdLCBzb3VyY2VzSW5kZXgpO1xuICAgICAgc291cmNlTGluZSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzJdLCBzb3VyY2VMaW5lKTtcbiAgICAgIHNvdXJjZUNvbHVtbiA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzNdLCBzb3VyY2VDb2x1bW4pO1xuICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSA0KSBjb250aW51ZTtcbiAgICAgIG5hbWVzSW5kZXggPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc2VnbWVudFs0XSwgbmFtZXNJbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB3cml0ZXIuZmx1c2goKTtcbn1cbmV4cG9ydCB7XG4gIGRlY29kZSxcbiAgZGVjb2RlR2VuZXJhdGVkUmFuZ2VzLFxuICBkZWNvZGVPcmlnaW5hbFNjb3BlcyxcbiAgZW5jb2RlLFxuICBlbmNvZGVHZW5lcmF0ZWRSYW5nZXMsXG4gIGVuY29kZU9yaWdpbmFsU2NvcGVzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c291cmNlbWFwLWNvZGVjLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnyMap: () => (/* binding */ FlattenMap),\n/* harmony export */   FlattenMap: () => (/* binding */ FlattenMap),\n/* harmony export */   GREATEST_LOWER_BOUND: () => (/* binding */ GREATEST_LOWER_BOUND),\n/* harmony export */   LEAST_UPPER_BOUND: () => (/* binding */ LEAST_UPPER_BOUND),\n/* harmony export */   TraceMap: () => (/* binding */ TraceMap),\n/* harmony export */   allGeneratedPositionsFor: () => (/* binding */ allGeneratedPositionsFor),\n/* harmony export */   decodedMap: () => (/* binding */ decodedMap),\n/* harmony export */   decodedMappings: () => (/* binding */ decodedMappings),\n/* harmony export */   eachMapping: () => (/* binding */ eachMapping),\n/* harmony export */   encodedMap: () => (/* binding */ encodedMap),\n/* harmony export */   encodedMappings: () => (/* binding */ encodedMappings),\n/* harmony export */   generatedPositionFor: () => (/* binding */ generatedPositionFor),\n/* harmony export */   isIgnored: () => (/* binding */ isIgnored),\n/* harmony export */   originalPositionFor: () => (/* binding */ originalPositionFor),\n/* harmony export */   presortedDecodedMap: () => (/* binding */ presortedDecodedMap),\n/* harmony export */   sourceContentFor: () => (/* binding */ sourceContentFor),\n/* harmony export */   traceSegment: () => (/* binding */ traceSegment)\n/* harmony export */ });\n/* harmony import */ var _jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jridgewell/sourcemap-codec */ \"(ssr)/./node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\");\n/* harmony import */ var _jridgewell_resolve_uri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jridgewell/resolve-uri */ \"(ssr)/./node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs\");\n// src/trace-mapping.ts\n\n\n// src/resolve.ts\n\n\n// src/strip-filename.ts\nfunction stripFilename(path) {\n  if (!path) return \"\";\n  const index = path.lastIndexOf(\"/\");\n  return path.slice(0, index + 1);\n}\n\n// src/resolve.ts\nfunction resolver(mapUrl, sourceRoot) {\n  const from = stripFilename(mapUrl);\n  const prefix = sourceRoot ? sourceRoot + \"/\" : \"\";\n  return (source) => (0,_jridgewell_resolve_uri__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(prefix + (source || \"\"), from);\n}\n\n// src/sourcemap-segment.ts\nvar COLUMN = 0;\nvar SOURCES_INDEX = 1;\nvar SOURCE_LINE = 2;\nvar SOURCE_COLUMN = 3;\nvar NAMES_INDEX = 4;\nvar REV_GENERATED_LINE = 1;\nvar REV_GENERATED_COLUMN = 2;\n\n// src/sort.ts\nfunction maybeSort(mappings, owned) {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n  if (!owned) mappings = mappings.slice();\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\nfunction isSorted(line) {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction sortSegments(line, owned) {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[COLUMN] - b[COLUMN];\n}\n\n// src/binary-search.ts\nvar found = false;\nfunction binarySearch(haystack, needle, low, high) {\n  while (low <= high) {\n    const mid = low + (high - low >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  found = false;\n  return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction lowerBound(haystack, needle, index) {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction memoizedState() {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1\n  };\n}\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n  const { lastKey, lastNeedle, lastIndex } = state;\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n    if (needle >= lastNeedle) {\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n  return state.lastIndex = binarySearch(haystack, needle, low, high);\n}\n\n// src/by-source.ts\nfunction buildBySources(decoded, memos) {\n  const sources = memos.map(buildNullArray);\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n      const sourceIndex2 = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const originalSource = sources[sourceIndex2];\n      const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);\n      const memo = memos[sourceIndex2];\n      let index = upperBound(\n        originalLine,\n        sourceColumn,\n        memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine)\n      );\n      memo.lastIndex = ++index;\n      insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n  return sources;\n}\nfunction insert(array, index, value) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\nfunction buildNullArray() {\n  return { __proto__: null };\n}\n\n// src/types.ts\nfunction parse(map) {\n  return typeof map === \"string\" ? JSON.parse(map) : map;\n}\n\n// src/flatten-map.ts\nvar FlattenMap = function(map, mapUrl) {\n  const parsed = parse(map);\n  if (!(\"sections\" in parsed)) {\n    return new TraceMap(parsed, mapUrl);\n  }\n  const mappings = [];\n  const sources = [];\n  const sourcesContent = [];\n  const names = [];\n  const ignoreList = [];\n  recurse(\n    parsed,\n    mapUrl,\n    mappings,\n    sources,\n    sourcesContent,\n    names,\n    ignoreList,\n    0,\n    0,\n    Infinity,\n    Infinity\n  );\n  const joined = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n    ignoreList\n  };\n  return presortedDecodedMap(joined);\n};\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n  const { sections } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const { map, offset } = sections[i];\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n    addSection(\n      map,\n      mapUrl,\n      mappings,\n      sources,\n      sourcesContent,\n      names,\n      ignoreList,\n      lineOffset + offset.line,\n      columnOffset + offset.column,\n      sl,\n      sc\n    );\n  }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n  const parsed = parse(input);\n  if (\"sections\" in parsed) return recurse(...arguments);\n  const map = new TraceMap(parsed, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\n  append(sources, resolvedSources);\n  append(names, map.names);\n  if (contents) append(sourcesContent, contents);\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n  if (ignores) for (let i = 0; i < ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n    if (lineI > stopLine) return;\n    const out = getLine(mappings, lineI);\n    const cOffset = i === 0 ? columnOffset : 0;\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n      if (lineI === stopLine && column >= stopColumn) return;\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(\n        seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]\n      );\n    }\n  }\n}\nfunction append(arr, other) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n\n// src/trace-mapping.ts\nvar LINE_GTR_ZERO = \"`line` must be greater than 0 (lines start at line 1)\";\nvar COL_GTR_EQ_ZERO = \"`column` must be greater than or equal to 0 (columns start at column 0)\";\nvar LEAST_UPPER_BOUND = -1;\nvar GREATEST_LOWER_BOUND = 1;\nvar TraceMap = class {\n  constructor(map, mapUrl) {\n    const isString = typeof map === \"string\";\n    if (!isString && map._decodedMemo) return map;\n    const parsed = parse(map);\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names || [];\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;\n    const resolve = resolver(mapUrl, sourceRoot);\n    this.resolvedSources = sources.map(resolve);\n    const { mappings } = parsed;\n    if (typeof mappings === \"string\") {\n      this._encoded = mappings;\n      this._decoded = void 0;\n    } else if (Array.isArray(mappings)) {\n      this._encoded = void 0;\n      this._decoded = maybeSort(mappings, isString);\n    } else if (parsed.sections) {\n      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);\n    } else {\n      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);\n    }\n    this._decodedMemo = memoizedState();\n    this._bySources = void 0;\n    this._bySourceMemos = void 0;\n  }\n};\nfunction cast(map) {\n  return map;\n}\nfunction encodedMappings(map) {\n  var _a, _b;\n  return (_b = (_a = cast(map))._encoded) != null ? _b : _a._encoded = (0,_jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_0__.encode)(cast(map)._decoded);\n}\nfunction decodedMappings(map) {\n  var _a;\n  return (_a = cast(map))._decoded || (_a._decoded = (0,_jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_0__.decode)(cast(map)._encoded));\n}\nfunction traceSegment(map, line, column) {\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length) return null;\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    GREATEST_LOWER_BOUND\n  );\n  return index === -1 ? null : segments[index];\n}\nfunction originalPositionFor(map, needle) {\n  let { line, column, bias } = needle;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const decoded = decodedMappings(map);\n  if (line >= decoded.length) return OMapping(null, null, null, null);\n  const segments = decoded[line];\n  const index = traceSegmentInternal(\n    segments,\n    cast(map)._decodedMemo,\n    line,\n    column,\n    bias || GREATEST_LOWER_BOUND\n  );\n  if (index === -1) return OMapping(null, null, null, null);\n  const segment = segments[index];\n  if (segment.length === 1) return OMapping(null, null, null, null);\n  const { names, resolvedSources } = map;\n  return OMapping(\n    resolvedSources[segment[SOURCES_INDEX]],\n    segment[SOURCE_LINE] + 1,\n    segment[SOURCE_COLUMN],\n    segment.length === 5 ? names[segment[NAMES_INDEX]] : null\n  );\n}\nfunction generatedPositionFor(map, needle) {\n  const { source, line, column, bias } = needle;\n  return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\nfunction allGeneratedPositionsFor(map, needle) {\n  const { source, line, column, bias } = needle;\n  return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\nfunction eachMapping(map, cb) {\n  const decoded = decodedMappings(map);\n  const { names, resolvedSources } = map;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const generatedLine = i + 1;\n      const generatedColumn = seg[0];\n      let source = null;\n      let originalLine = null;\n      let originalColumn = null;\n      let name = null;\n      if (seg.length !== 1) {\n        source = resolvedSources[seg[1]];\n        originalLine = seg[2] + 1;\n        originalColumn = seg[3];\n      }\n      if (seg.length === 5) name = names[seg[4]];\n      cb({\n        generatedLine,\n        generatedColumn,\n        source,\n        originalLine,\n        originalColumn,\n        name\n      });\n    }\n  }\n}\nfunction sourceIndex(map, source) {\n  const { sources, resolvedSources } = map;\n  let index = sources.indexOf(source);\n  if (index === -1) index = resolvedSources.indexOf(source);\n  return index;\n}\nfunction sourceContentFor(map, source) {\n  const { sourcesContent } = map;\n  if (sourcesContent == null) return null;\n  const index = sourceIndex(map, source);\n  return index === -1 ? null : sourcesContent[index];\n}\nfunction isIgnored(map, source) {\n  const { ignoreList } = map;\n  if (ignoreList == null) return false;\n  const index = sourceIndex(map, source);\n  return index === -1 ? false : ignoreList.includes(index);\n}\nfunction presortedDecodedMap(map, mapUrl) {\n  const tracer = new TraceMap(clone(map, []), mapUrl);\n  cast(tracer)._decoded = map.mappings;\n  return tracer;\n}\nfunction decodedMap(map) {\n  return clone(map, decodedMappings(map));\n}\nfunction encodedMap(map) {\n  return clone(map, encodedMappings(map));\n}\nfunction clone(map, mappings) {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n    ignoreList: map.ignoreList || map.x_google_ignoreList\n  };\n}\nfunction OMapping(source, line, column, name) {\n  return { source, line, column, name };\n}\nfunction GMapping(line, column) {\n  return { line, column };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (found) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n  if (!found && bias === LEAST_UPPER_BOUND) min++;\n  if (min === -1 || min === segments.length) return [];\n  const matchedColumn = found ? column : segments[min][COLUMN];\n  if (!found) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\nfunction generatedPosition(map, source, line, column, bias, all) {\n  var _a;\n  line--;\n  if (line < 0) throw new Error(LINE_GTR_ZERO);\n  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n  const { sources, resolvedSources } = map;\n  let sourceIndex2 = sources.indexOf(source);\n  if (sourceIndex2 === -1) sourceIndex2 = resolvedSources.indexOf(source);\n  if (sourceIndex2 === -1) return all ? [] : GMapping(null, null);\n  const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(\n    decodedMappings(map),\n    cast(map)._bySourceMemos = sources.map(memoizedState)\n  ));\n  const segments = generated[sourceIndex2][line];\n  if (segments == null) return all ? [] : GMapping(null, null);\n  const memo = cast(map)._bySourceMemos[sourceIndex2];\n  if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n  const index = traceSegmentInternal(segments, memo, line, column, bias);\n  if (index === -1) return GMapping(null, null);\n  const segment = segments[index];\n  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\n\n//# sourceMappingURL=trace-mapping.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZy9kaXN0L3RyYWNlLW1hcHBpbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUM2RDs7QUFFN0Q7QUFDaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtRUFBVTtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUJBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckIsa0JBQWtCLHFCQUFxQjtBQUN2QyxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlFQUFpRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25ELCtCQUErQixvQkFBb0I7QUFDbkQsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNERBQTREO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTiw2Q0FBNkMsdUJBQXVCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsbUVBQU07QUFDN0U7QUFDQTtBQUNBO0FBQ0EscURBQXFELG1FQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUJBQXFCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkMsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFtQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3VpLWxpYnJhcnktZG9jcy8uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC90cmFjZS1tYXBwaW5nL2Rpc3QvdHJhY2UtbWFwcGluZy5tanM/NDJmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdHJhY2UtbWFwcGluZy50c1xuaW1wb3J0IHsgZW5jb2RlLCBkZWNvZGUgfSBmcm9tIFwiQGpyaWRnZXdlbGwvc291cmNlbWFwLWNvZGVjXCI7XG5cbi8vIHNyYy9yZXNvbHZlLnRzXG5pbXBvcnQgcmVzb2x2ZVVyaSBmcm9tIFwiQGpyaWRnZXdlbGwvcmVzb2x2ZS11cmlcIjtcblxuLy8gc3JjL3N0cmlwLWZpbGVuYW1lLnRzXG5mdW5jdGlvbiBzdHJpcEZpbGVuYW1lKHBhdGgpIHtcbiAgaWYgKCFwYXRoKSByZXR1cm4gXCJcIjtcbiAgY29uc3QgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgaW5kZXggKyAxKTtcbn1cblxuLy8gc3JjL3Jlc29sdmUudHNcbmZ1bmN0aW9uIHJlc29sdmVyKG1hcFVybCwgc291cmNlUm9vdCkge1xuICBjb25zdCBmcm9tID0gc3RyaXBGaWxlbmFtZShtYXBVcmwpO1xuICBjb25zdCBwcmVmaXggPSBzb3VyY2VSb290ID8gc291cmNlUm9vdCArIFwiL1wiIDogXCJcIjtcbiAgcmV0dXJuIChzb3VyY2UpID0+IHJlc29sdmVVcmkocHJlZml4ICsgKHNvdXJjZSB8fCBcIlwiKSwgZnJvbSk7XG59XG5cbi8vIHNyYy9zb3VyY2VtYXAtc2VnbWVudC50c1xudmFyIENPTFVNTiA9IDA7XG52YXIgU09VUkNFU19JTkRFWCA9IDE7XG52YXIgU09VUkNFX0xJTkUgPSAyO1xudmFyIFNPVVJDRV9DT0xVTU4gPSAzO1xudmFyIE5BTUVTX0lOREVYID0gNDtcbnZhciBSRVZfR0VORVJBVEVEX0xJTkUgPSAxO1xudmFyIFJFVl9HRU5FUkFURURfQ09MVU1OID0gMjtcblxuLy8gc3JjL3NvcnQudHNcbmZ1bmN0aW9uIG1heWJlU29ydChtYXBwaW5ncywgb3duZWQpIHtcbiAgY29uc3QgdW5zb3J0ZWRJbmRleCA9IG5leHRVbnNvcnRlZFNlZ21lbnRMaW5lKG1hcHBpbmdzLCAwKTtcbiAgaWYgKHVuc29ydGVkSW5kZXggPT09IG1hcHBpbmdzLmxlbmd0aCkgcmV0dXJuIG1hcHBpbmdzO1xuICBpZiAoIW93bmVkKSBtYXBwaW5ncyA9IG1hcHBpbmdzLnNsaWNlKCk7XG4gIGZvciAobGV0IGkgPSB1bnNvcnRlZEluZGV4OyBpIDwgbWFwcGluZ3MubGVuZ3RoOyBpID0gbmV4dFVuc29ydGVkU2VnbWVudExpbmUobWFwcGluZ3MsIGkgKyAxKSkge1xuICAgIG1hcHBpbmdzW2ldID0gc29ydFNlZ21lbnRzKG1hcHBpbmdzW2ldLCBvd25lZCk7XG4gIH1cbiAgcmV0dXJuIG1hcHBpbmdzO1xufVxuZnVuY3Rpb24gbmV4dFVuc29ydGVkU2VnbWVudExpbmUobWFwcGluZ3MsIHN0YXJ0KSB7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG1hcHBpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFpc1NvcnRlZChtYXBwaW5nc1tpXSkpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiBtYXBwaW5ncy5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc1NvcnRlZChsaW5lKSB7XG4gIGZvciAobGV0IGogPSAxOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgIGlmIChsaW5lW2pdW0NPTFVNTl0gPCBsaW5lW2ogLSAxXVtDT0xVTU5dKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc29ydFNlZ21lbnRzKGxpbmUsIG93bmVkKSB7XG4gIGlmICghb3duZWQpIGxpbmUgPSBsaW5lLnNsaWNlKCk7XG4gIHJldHVybiBsaW5lLnNvcnQoc29ydENvbXBhcmF0b3IpO1xufVxuZnVuY3Rpb24gc29ydENvbXBhcmF0b3IoYSwgYikge1xuICByZXR1cm4gYVtDT0xVTU5dIC0gYltDT0xVTU5dO1xufVxuXG4vLyBzcmMvYmluYXJ5LXNlYXJjaC50c1xudmFyIGZvdW5kID0gZmFsc2U7XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2goaGF5c3RhY2ssIG5lZWRsZSwgbG93LCBoaWdoKSB7XG4gIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgIGNvbnN0IG1pZCA9IGxvdyArIChoaWdoIC0gbG93ID4+IDEpO1xuICAgIGNvbnN0IGNtcCA9IGhheXN0YWNrW21pZF1bQ09MVU1OXSAtIG5lZWRsZTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICBmb3VuZCA9IHRydWU7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgICBpZiAoY21wIDwgMCkge1xuICAgICAgbG93ID0gbWlkICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgfVxuICB9XG4gIGZvdW5kID0gZmFsc2U7XG4gIHJldHVybiBsb3cgLSAxO1xufVxuZnVuY3Rpb24gdXBwZXJCb3VuZChoYXlzdGFjaywgbmVlZGxlLCBpbmRleCkge1xuICBmb3IgKGxldCBpID0gaW5kZXggKyAxOyBpIDwgaGF5c3RhY2subGVuZ3RoOyBpbmRleCA9IGkrKykge1xuICAgIGlmIChoYXlzdGFja1tpXVtDT0xVTU5dICE9PSBuZWVkbGUpIGJyZWFrO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGxvd2VyQm91bmQoaGF5c3RhY2ssIG5lZWRsZSwgaW5kZXgpIHtcbiAgZm9yIChsZXQgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpbmRleCA9IGktLSkge1xuICAgIGlmIChoYXlzdGFja1tpXVtDT0xVTU5dICE9PSBuZWVkbGUpIGJyZWFrO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIG1lbW9pemVkU3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgbGFzdEtleTogLTEsXG4gICAgbGFzdE5lZWRsZTogLTEsXG4gICAgbGFzdEluZGV4OiAtMVxuICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZWRCaW5hcnlTZWFyY2goaGF5c3RhY2ssIG5lZWRsZSwgc3RhdGUsIGtleSkge1xuICBjb25zdCB7IGxhc3RLZXksIGxhc3ROZWVkbGUsIGxhc3RJbmRleCB9ID0gc3RhdGU7XG4gIGxldCBsb3cgPSAwO1xuICBsZXQgaGlnaCA9IGhheXN0YWNrLmxlbmd0aCAtIDE7XG4gIGlmIChrZXkgPT09IGxhc3RLZXkpIHtcbiAgICBpZiAobmVlZGxlID09PSBsYXN0TmVlZGxlKSB7XG4gICAgICBmb3VuZCA9IGxhc3RJbmRleCAhPT0gLTEgJiYgaGF5c3RhY2tbbGFzdEluZGV4XVtDT0xVTU5dID09PSBuZWVkbGU7XG4gICAgICByZXR1cm4gbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAobmVlZGxlID49IGxhc3ROZWVkbGUpIHtcbiAgICAgIGxvdyA9IGxhc3RJbmRleCA9PT0gLTEgPyAwIDogbGFzdEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWdoID0gbGFzdEluZGV4O1xuICAgIH1cbiAgfVxuICBzdGF0ZS5sYXN0S2V5ID0ga2V5O1xuICBzdGF0ZS5sYXN0TmVlZGxlID0gbmVlZGxlO1xuICByZXR1cm4gc3RhdGUubGFzdEluZGV4ID0gYmluYXJ5U2VhcmNoKGhheXN0YWNrLCBuZWVkbGUsIGxvdywgaGlnaCk7XG59XG5cbi8vIHNyYy9ieS1zb3VyY2UudHNcbmZ1bmN0aW9uIGJ1aWxkQnlTb3VyY2VzKGRlY29kZWQsIG1lbW9zKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBtZW1vcy5tYXAoYnVpbGROdWxsQXJyYXkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gZGVjb2RlZFtpXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHNlZyA9IGxpbmVbal07XG4gICAgICBpZiAoc2VnLmxlbmd0aCA9PT0gMSkgY29udGludWU7XG4gICAgICBjb25zdCBzb3VyY2VJbmRleDIgPSBzZWdbU09VUkNFU19JTkRFWF07XG4gICAgICBjb25zdCBzb3VyY2VMaW5lID0gc2VnW1NPVVJDRV9MSU5FXTtcbiAgICAgIGNvbnN0IHNvdXJjZUNvbHVtbiA9IHNlZ1tTT1VSQ0VfQ09MVU1OXTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsU291cmNlID0gc291cmNlc1tzb3VyY2VJbmRleDJdO1xuICAgICAgY29uc3Qgb3JpZ2luYWxMaW5lID0gb3JpZ2luYWxTb3VyY2Vbc291cmNlTGluZV0gfHwgKG9yaWdpbmFsU291cmNlW3NvdXJjZUxpbmVdID0gW10pO1xuICAgICAgY29uc3QgbWVtbyA9IG1lbW9zW3NvdXJjZUluZGV4Ml07XG4gICAgICBsZXQgaW5kZXggPSB1cHBlckJvdW5kKFxuICAgICAgICBvcmlnaW5hbExpbmUsXG4gICAgICAgIHNvdXJjZUNvbHVtbixcbiAgICAgICAgbWVtb2l6ZWRCaW5hcnlTZWFyY2gob3JpZ2luYWxMaW5lLCBzb3VyY2VDb2x1bW4sIG1lbW8sIHNvdXJjZUxpbmUpXG4gICAgICApO1xuICAgICAgbWVtby5sYXN0SW5kZXggPSArK2luZGV4O1xuICAgICAgaW5zZXJ0KG9yaWdpbmFsTGluZSwgaW5kZXgsIFtzb3VyY2VDb2x1bW4sIGksIHNlZ1tDT0xVTU5dXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzb3VyY2VzO1xufVxuZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcbiAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aDsgaSA+IGluZGV4OyBpLS0pIHtcbiAgICBhcnJheVtpXSA9IGFycmF5W2kgLSAxXTtcbiAgfVxuICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTnVsbEFycmF5KCkge1xuICByZXR1cm4geyBfX3Byb3RvX186IG51bGwgfTtcbn1cblxuLy8gc3JjL3R5cGVzLnRzXG5mdW5jdGlvbiBwYXJzZShtYXApIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXAgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKG1hcCkgOiBtYXA7XG59XG5cbi8vIHNyYy9mbGF0dGVuLW1hcC50c1xudmFyIEZsYXR0ZW5NYXAgPSBmdW5jdGlvbihtYXAsIG1hcFVybCkge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZShtYXApO1xuICBpZiAoIShcInNlY3Rpb25zXCIgaW4gcGFyc2VkKSkge1xuICAgIHJldHVybiBuZXcgVHJhY2VNYXAocGFyc2VkLCBtYXBVcmwpO1xuICB9XG4gIGNvbnN0IG1hcHBpbmdzID0gW107XG4gIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgY29uc3Qgc291cmNlc0NvbnRlbnQgPSBbXTtcbiAgY29uc3QgbmFtZXMgPSBbXTtcbiAgY29uc3QgaWdub3JlTGlzdCA9IFtdO1xuICByZWN1cnNlKFxuICAgIHBhcnNlZCxcbiAgICBtYXBVcmwsXG4gICAgbWFwcGluZ3MsXG4gICAgc291cmNlcyxcbiAgICBzb3VyY2VzQ29udGVudCxcbiAgICBuYW1lcyxcbiAgICBpZ25vcmVMaXN0LFxuICAgIDAsXG4gICAgMCxcbiAgICBJbmZpbml0eSxcbiAgICBJbmZpbml0eVxuICApO1xuICBjb25zdCBqb2luZWQgPSB7XG4gICAgdmVyc2lvbjogMyxcbiAgICBmaWxlOiBwYXJzZWQuZmlsZSxcbiAgICBuYW1lcyxcbiAgICBzb3VyY2VzLFxuICAgIHNvdXJjZXNDb250ZW50LFxuICAgIG1hcHBpbmdzLFxuICAgIGlnbm9yZUxpc3RcbiAgfTtcbiAgcmV0dXJuIHByZXNvcnRlZERlY29kZWRNYXAoam9pbmVkKTtcbn07XG5mdW5jdGlvbiByZWN1cnNlKGlucHV0LCBtYXBVcmwsIG1hcHBpbmdzLCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCwgbmFtZXMsIGlnbm9yZUxpc3QsIGxpbmVPZmZzZXQsIGNvbHVtbk9mZnNldCwgc3RvcExpbmUsIHN0b3BDb2x1bW4pIHtcbiAgY29uc3QgeyBzZWN0aW9ucyB9ID0gaW5wdXQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7IG1hcCwgb2Zmc2V0IH0gPSBzZWN0aW9uc1tpXTtcbiAgICBsZXQgc2wgPSBzdG9wTGluZTtcbiAgICBsZXQgc2MgPSBzdG9wQ29sdW1uO1xuICAgIGlmIChpICsgMSA8IHNlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmV4dE9mZnNldCA9IHNlY3Rpb25zW2kgKyAxXS5vZmZzZXQ7XG4gICAgICBzbCA9IE1hdGgubWluKHN0b3BMaW5lLCBsaW5lT2Zmc2V0ICsgbmV4dE9mZnNldC5saW5lKTtcbiAgICAgIGlmIChzbCA9PT0gc3RvcExpbmUpIHtcbiAgICAgICAgc2MgPSBNYXRoLm1pbihzdG9wQ29sdW1uLCBjb2x1bW5PZmZzZXQgKyBuZXh0T2Zmc2V0LmNvbHVtbik7XG4gICAgICB9IGVsc2UgaWYgKHNsIDwgc3RvcExpbmUpIHtcbiAgICAgICAgc2MgPSBjb2x1bW5PZmZzZXQgKyBuZXh0T2Zmc2V0LmNvbHVtbjtcbiAgICAgIH1cbiAgICB9XG4gICAgYWRkU2VjdGlvbihcbiAgICAgIG1hcCxcbiAgICAgIG1hcFVybCxcbiAgICAgIG1hcHBpbmdzLFxuICAgICAgc291cmNlcyxcbiAgICAgIHNvdXJjZXNDb250ZW50LFxuICAgICAgbmFtZXMsXG4gICAgICBpZ25vcmVMaXN0LFxuICAgICAgbGluZU9mZnNldCArIG9mZnNldC5saW5lLFxuICAgICAgY29sdW1uT2Zmc2V0ICsgb2Zmc2V0LmNvbHVtbixcbiAgICAgIHNsLFxuICAgICAgc2NcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBhZGRTZWN0aW9uKGlucHV0LCBtYXBVcmwsIG1hcHBpbmdzLCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCwgbmFtZXMsIGlnbm9yZUxpc3QsIGxpbmVPZmZzZXQsIGNvbHVtbk9mZnNldCwgc3RvcExpbmUsIHN0b3BDb2x1bW4pIHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2UoaW5wdXQpO1xuICBpZiAoXCJzZWN0aW9uc1wiIGluIHBhcnNlZCkgcmV0dXJuIHJlY3Vyc2UoLi4uYXJndW1lbnRzKTtcbiAgY29uc3QgbWFwID0gbmV3IFRyYWNlTWFwKHBhcnNlZCwgbWFwVXJsKTtcbiAgY29uc3Qgc291cmNlc09mZnNldCA9IHNvdXJjZXMubGVuZ3RoO1xuICBjb25zdCBuYW1lc09mZnNldCA9IG5hbWVzLmxlbmd0aDtcbiAgY29uc3QgZGVjb2RlZCA9IGRlY29kZWRNYXBwaW5ncyhtYXApO1xuICBjb25zdCB7IHJlc29sdmVkU291cmNlcywgc291cmNlc0NvbnRlbnQ6IGNvbnRlbnRzLCBpZ25vcmVMaXN0OiBpZ25vcmVzIH0gPSBtYXA7XG4gIGFwcGVuZChzb3VyY2VzLCByZXNvbHZlZFNvdXJjZXMpO1xuICBhcHBlbmQobmFtZXMsIG1hcC5uYW1lcyk7XG4gIGlmIChjb250ZW50cykgYXBwZW5kKHNvdXJjZXNDb250ZW50LCBjb250ZW50cyk7XG4gIGVsc2UgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZFNvdXJjZXMubGVuZ3RoOyBpKyspIHNvdXJjZXNDb250ZW50LnB1c2gobnVsbCk7XG4gIGlmIChpZ25vcmVzKSBmb3IgKGxldCBpID0gMDsgaSA8IGlnbm9yZXMubGVuZ3RoOyBpKyspIGlnbm9yZUxpc3QucHVzaChpZ25vcmVzW2ldICsgc291cmNlc09mZnNldCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmVJID0gbGluZU9mZnNldCArIGk7XG4gICAgaWYgKGxpbmVJID4gc3RvcExpbmUpIHJldHVybjtcbiAgICBjb25zdCBvdXQgPSBnZXRMaW5lKG1hcHBpbmdzLCBsaW5lSSk7XG4gICAgY29uc3QgY09mZnNldCA9IGkgPT09IDAgPyBjb2x1bW5PZmZzZXQgOiAwO1xuICAgIGNvbnN0IGxpbmUgPSBkZWNvZGVkW2ldO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3Qgc2VnID0gbGluZVtqXTtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IGNPZmZzZXQgKyBzZWdbQ09MVU1OXTtcbiAgICAgIGlmIChsaW5lSSA9PT0gc3RvcExpbmUgJiYgY29sdW1uID49IHN0b3BDb2x1bW4pIHJldHVybjtcbiAgICAgIGlmIChzZWcubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG91dC5wdXNoKFtjb2x1bW5dKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzb3VyY2VzSW5kZXggPSBzb3VyY2VzT2Zmc2V0ICsgc2VnW1NPVVJDRVNfSU5ERVhdO1xuICAgICAgY29uc3Qgc291cmNlTGluZSA9IHNlZ1tTT1VSQ0VfTElORV07XG4gICAgICBjb25zdCBzb3VyY2VDb2x1bW4gPSBzZWdbU09VUkNFX0NPTFVNTl07XG4gICAgICBvdXQucHVzaChcbiAgICAgICAgc2VnLmxlbmd0aCA9PT0gNCA/IFtjb2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uXSA6IFtjb2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lc09mZnNldCArIHNlZ1tOQU1FU19JTkRFWF1dXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXBwZW5kKGFyciwgb3RoZXIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdGhlci5sZW5ndGg7IGkrKykgYXJyLnB1c2gob3RoZXJbaV0pO1xufVxuZnVuY3Rpb24gZ2V0TGluZShhcnIsIGluZGV4KSB7XG4gIGZvciAobGV0IGkgPSBhcnIubGVuZ3RoOyBpIDw9IGluZGV4OyBpKyspIGFycltpXSA9IFtdO1xuICByZXR1cm4gYXJyW2luZGV4XTtcbn1cblxuLy8gc3JjL3RyYWNlLW1hcHBpbmcudHNcbnZhciBMSU5FX0dUUl9aRVJPID0gXCJgbGluZWAgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCAobGluZXMgc3RhcnQgYXQgbGluZSAxKVwiO1xudmFyIENPTF9HVFJfRVFfWkVSTyA9IFwiYGNvbHVtbmAgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCAoY29sdW1ucyBzdGFydCBhdCBjb2x1bW4gMClcIjtcbnZhciBMRUFTVF9VUFBFUl9CT1VORCA9IC0xO1xudmFyIEdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcbnZhciBUcmFjZU1hcCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWFwLCBtYXBVcmwpIHtcbiAgICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBtYXAgPT09IFwic3RyaW5nXCI7XG4gICAgaWYgKCFpc1N0cmluZyAmJiBtYXAuX2RlY29kZWRNZW1vKSByZXR1cm4gbWFwO1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKG1hcCk7XG4gICAgY29uc3QgeyB2ZXJzaW9uLCBmaWxlLCBuYW1lcywgc291cmNlUm9vdCwgc291cmNlcywgc291cmNlc0NvbnRlbnQgfSA9IHBhcnNlZDtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgdGhpcy5uYW1lcyA9IG5hbWVzIHx8IFtdO1xuICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gICAgdGhpcy5pZ25vcmVMaXN0ID0gcGFyc2VkLmlnbm9yZUxpc3QgfHwgcGFyc2VkLnhfZ29vZ2xlX2lnbm9yZUxpc3QgfHwgdm9pZCAwO1xuICAgIGNvbnN0IHJlc29sdmUgPSByZXNvbHZlcihtYXBVcmwsIHNvdXJjZVJvb3QpO1xuICAgIHRoaXMucmVzb2x2ZWRTb3VyY2VzID0gc291cmNlcy5tYXAocmVzb2x2ZSk7XG4gICAgY29uc3QgeyBtYXBwaW5ncyB9ID0gcGFyc2VkO1xuICAgIGlmICh0eXBlb2YgbWFwcGluZ3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuX2VuY29kZWQgPSBtYXBwaW5ncztcbiAgICAgIHRoaXMuX2RlY29kZWQgPSB2b2lkIDA7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1hcHBpbmdzKSkge1xuICAgICAgdGhpcy5fZW5jb2RlZCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2RlY29kZWQgPSBtYXliZVNvcnQobWFwcGluZ3MsIGlzU3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC5zZWN0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFjZU1hcCBwYXNzZWQgc2VjdGlvbmVkIHNvdXJjZSBtYXAsIHBsZWFzZSB1c2UgRmxhdHRlbk1hcCBleHBvcnQgaW5zdGVhZGApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc291cmNlIG1hcDogJHtKU09OLnN0cmluZ2lmeShwYXJzZWQpfWApO1xuICAgIH1cbiAgICB0aGlzLl9kZWNvZGVkTWVtbyA9IG1lbW9pemVkU3RhdGUoKTtcbiAgICB0aGlzLl9ieVNvdXJjZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5fYnlTb3VyY2VNZW1vcyA9IHZvaWQgMDtcbiAgfVxufTtcbmZ1bmN0aW9uIGNhc3QobWFwKSB7XG4gIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBlbmNvZGVkTWFwcGluZ3MobWFwKSB7XG4gIHZhciBfYSwgX2I7XG4gIHJldHVybiAoX2IgPSAoX2EgPSBjYXN0KG1hcCkpLl9lbmNvZGVkKSAhPSBudWxsID8gX2IgOiBfYS5fZW5jb2RlZCA9IGVuY29kZShjYXN0KG1hcCkuX2RlY29kZWQpO1xufVxuZnVuY3Rpb24gZGVjb2RlZE1hcHBpbmdzKG1hcCkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBjYXN0KG1hcCkpLl9kZWNvZGVkIHx8IChfYS5fZGVjb2RlZCA9IGRlY29kZShjYXN0KG1hcCkuX2VuY29kZWQpKTtcbn1cbmZ1bmN0aW9uIHRyYWNlU2VnbWVudChtYXAsIGxpbmUsIGNvbHVtbikge1xuICBjb25zdCBkZWNvZGVkID0gZGVjb2RlZE1hcHBpbmdzKG1hcCk7XG4gIGlmIChsaW5lID49IGRlY29kZWQubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgY29uc3Qgc2VnbWVudHMgPSBkZWNvZGVkW2xpbmVdO1xuICBjb25zdCBpbmRleCA9IHRyYWNlU2VnbWVudEludGVybmFsKFxuICAgIHNlZ21lbnRzLFxuICAgIGNhc3QobWFwKS5fZGVjb2RlZE1lbW8sXG4gICAgbGluZSxcbiAgICBjb2x1bW4sXG4gICAgR1JFQVRFU1RfTE9XRVJfQk9VTkRcbiAgKTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/IG51bGwgOiBzZWdtZW50c1tpbmRleF07XG59XG5mdW5jdGlvbiBvcmlnaW5hbFBvc2l0aW9uRm9yKG1hcCwgbmVlZGxlKSB7XG4gIGxldCB7IGxpbmUsIGNvbHVtbiwgYmlhcyB9ID0gbmVlZGxlO1xuICBsaW5lLS07XG4gIGlmIChsaW5lIDwgMCkgdGhyb3cgbmV3IEVycm9yKExJTkVfR1RSX1pFUk8pO1xuICBpZiAoY29sdW1uIDwgMCkgdGhyb3cgbmV3IEVycm9yKENPTF9HVFJfRVFfWkVSTyk7XG4gIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVkTWFwcGluZ3MobWFwKTtcbiAgaWYgKGxpbmUgPj0gZGVjb2RlZC5sZW5ndGgpIHJldHVybiBPTWFwcGluZyhudWxsLCBudWxsLCBudWxsLCBudWxsKTtcbiAgY29uc3Qgc2VnbWVudHMgPSBkZWNvZGVkW2xpbmVdO1xuICBjb25zdCBpbmRleCA9IHRyYWNlU2VnbWVudEludGVybmFsKFxuICAgIHNlZ21lbnRzLFxuICAgIGNhc3QobWFwKS5fZGVjb2RlZE1lbW8sXG4gICAgbGluZSxcbiAgICBjb2x1bW4sXG4gICAgYmlhcyB8fCBHUkVBVEVTVF9MT1dFUl9CT1VORFxuICApO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gT01hcHBpbmcobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG4gIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIE9NYXBwaW5nKG51bGwsIG51bGwsIG51bGwsIG51bGwpO1xuICBjb25zdCB7IG5hbWVzLCByZXNvbHZlZFNvdXJjZXMgfSA9IG1hcDtcbiAgcmV0dXJuIE9NYXBwaW5nKFxuICAgIHJlc29sdmVkU291cmNlc1tzZWdtZW50W1NPVVJDRVNfSU5ERVhdXSxcbiAgICBzZWdtZW50W1NPVVJDRV9MSU5FXSArIDEsXG4gICAgc2VnbWVudFtTT1VSQ0VfQ09MVU1OXSxcbiAgICBzZWdtZW50Lmxlbmd0aCA9PT0gNSA/IG5hbWVzW3NlZ21lbnRbTkFNRVNfSU5ERVhdXSA6IG51bGxcbiAgKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uRm9yKG1hcCwgbmVlZGxlKSB7XG4gIGNvbnN0IHsgc291cmNlLCBsaW5lLCBjb2x1bW4sIGJpYXMgfSA9IG5lZWRsZTtcbiAgcmV0dXJuIGdlbmVyYXRlZFBvc2l0aW9uKG1hcCwgc291cmNlLCBsaW5lLCBjb2x1bW4sIGJpYXMgfHwgR1JFQVRFU1RfTE9XRVJfQk9VTkQsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihtYXAsIG5lZWRsZSkge1xuICBjb25zdCB7IHNvdXJjZSwgbGluZSwgY29sdW1uLCBiaWFzIH0gPSBuZWVkbGU7XG4gIHJldHVybiBnZW5lcmF0ZWRQb3NpdGlvbihtYXAsIHNvdXJjZSwgbGluZSwgY29sdW1uLCBiaWFzIHx8IExFQVNUX1VQUEVSX0JPVU5ELCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGVhY2hNYXBwaW5nKG1hcCwgY2IpIHtcbiAgY29uc3QgZGVjb2RlZCA9IGRlY29kZWRNYXBwaW5ncyhtYXApO1xuICBjb25zdCB7IG5hbWVzLCByZXNvbHZlZFNvdXJjZXMgfSA9IG1hcDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZSA9IGRlY29kZWRbaV07XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBzZWcgPSBsaW5lW2pdO1xuICAgICAgY29uc3QgZ2VuZXJhdGVkTGluZSA9IGkgKyAxO1xuICAgICAgY29uc3QgZ2VuZXJhdGVkQ29sdW1uID0gc2VnWzBdO1xuICAgICAgbGV0IHNvdXJjZSA9IG51bGw7XG4gICAgICBsZXQgb3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgICAgIGxldCBvcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gICAgICBsZXQgbmFtZSA9IG51bGw7XG4gICAgICBpZiAoc2VnLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICBzb3VyY2UgPSByZXNvbHZlZFNvdXJjZXNbc2VnWzFdXTtcbiAgICAgICAgb3JpZ2luYWxMaW5lID0gc2VnWzJdICsgMTtcbiAgICAgICAgb3JpZ2luYWxDb2x1bW4gPSBzZWdbM107XG4gICAgICB9XG4gICAgICBpZiAoc2VnLmxlbmd0aCA9PT0gNSkgbmFtZSA9IG5hbWVzW3NlZ1s0XV07XG4gICAgICBjYih7XG4gICAgICAgIGdlbmVyYXRlZExpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBvcmlnaW5hbExpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uLFxuICAgICAgICBuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNvdXJjZUluZGV4KG1hcCwgc291cmNlKSB7XG4gIGNvbnN0IHsgc291cmNlcywgcmVzb2x2ZWRTb3VyY2VzIH0gPSBtYXA7XG4gIGxldCBpbmRleCA9IHNvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuICBpZiAoaW5kZXggPT09IC0xKSBpbmRleCA9IHJlc29sdmVkU291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNvdXJjZUNvbnRlbnRGb3IobWFwLCBzb3VyY2UpIHtcbiAgY29uc3QgeyBzb3VyY2VzQ29udGVudCB9ID0gbWFwO1xuICBpZiAoc291cmNlc0NvbnRlbnQgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGluZGV4ID0gc291cmNlSW5kZXgobWFwLCBzb3VyY2UpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gbnVsbCA6IHNvdXJjZXNDb250ZW50W2luZGV4XTtcbn1cbmZ1bmN0aW9uIGlzSWdub3JlZChtYXAsIHNvdXJjZSkge1xuICBjb25zdCB7IGlnbm9yZUxpc3QgfSA9IG1hcDtcbiAgaWYgKGlnbm9yZUxpc3QgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBpbmRleCA9IHNvdXJjZUluZGV4KG1hcCwgc291cmNlKTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/IGZhbHNlIDogaWdub3JlTGlzdC5pbmNsdWRlcyhpbmRleCk7XG59XG5mdW5jdGlvbiBwcmVzb3J0ZWREZWNvZGVkTWFwKG1hcCwgbWFwVXJsKSB7XG4gIGNvbnN0IHRyYWNlciA9IG5ldyBUcmFjZU1hcChjbG9uZShtYXAsIFtdKSwgbWFwVXJsKTtcbiAgY2FzdCh0cmFjZXIpLl9kZWNvZGVkID0gbWFwLm1hcHBpbmdzO1xuICByZXR1cm4gdHJhY2VyO1xufVxuZnVuY3Rpb24gZGVjb2RlZE1hcChtYXApIHtcbiAgcmV0dXJuIGNsb25lKG1hcCwgZGVjb2RlZE1hcHBpbmdzKG1hcCkpO1xufVxuZnVuY3Rpb24gZW5jb2RlZE1hcChtYXApIHtcbiAgcmV0dXJuIGNsb25lKG1hcCwgZW5jb2RlZE1hcHBpbmdzKG1hcCkpO1xufVxuZnVuY3Rpb24gY2xvbmUobWFwLCBtYXBwaW5ncykge1xuICByZXR1cm4ge1xuICAgIHZlcnNpb246IG1hcC52ZXJzaW9uLFxuICAgIGZpbGU6IG1hcC5maWxlLFxuICAgIG5hbWVzOiBtYXAubmFtZXMsXG4gICAgc291cmNlUm9vdDogbWFwLnNvdXJjZVJvb3QsXG4gICAgc291cmNlczogbWFwLnNvdXJjZXMsXG4gICAgc291cmNlc0NvbnRlbnQ6IG1hcC5zb3VyY2VzQ29udGVudCxcbiAgICBtYXBwaW5ncyxcbiAgICBpZ25vcmVMaXN0OiBtYXAuaWdub3JlTGlzdCB8fCBtYXAueF9nb29nbGVfaWdub3JlTGlzdFxuICB9O1xufVxuZnVuY3Rpb24gT01hcHBpbmcoc291cmNlLCBsaW5lLCBjb2x1bW4sIG5hbWUpIHtcbiAgcmV0dXJuIHsgc291cmNlLCBsaW5lLCBjb2x1bW4sIG5hbWUgfTtcbn1cbmZ1bmN0aW9uIEdNYXBwaW5nKGxpbmUsIGNvbHVtbikge1xuICByZXR1cm4geyBsaW5lLCBjb2x1bW4gfTtcbn1cbmZ1bmN0aW9uIHRyYWNlU2VnbWVudEludGVybmFsKHNlZ21lbnRzLCBtZW1vLCBsaW5lLCBjb2x1bW4sIGJpYXMpIHtcbiAgbGV0IGluZGV4ID0gbWVtb2l6ZWRCaW5hcnlTZWFyY2goc2VnbWVudHMsIGNvbHVtbiwgbWVtbywgbGluZSk7XG4gIGlmIChmb3VuZCkge1xuICAgIGluZGV4ID0gKGJpYXMgPT09IExFQVNUX1VQUEVSX0JPVU5EID8gdXBwZXJCb3VuZCA6IGxvd2VyQm91bmQpKHNlZ21lbnRzLCBjb2x1bW4sIGluZGV4KTtcbiAgfSBlbHNlIGlmIChiaWFzID09PSBMRUFTVF9VUFBFUl9CT1VORCkgaW5kZXgrKztcbiAgaWYgKGluZGV4ID09PSAtMSB8fCBpbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoKSByZXR1cm4gLTE7XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNsaWNlR2VuZXJhdGVkUG9zaXRpb25zKHNlZ21lbnRzLCBtZW1vLCBsaW5lLCBjb2x1bW4sIGJpYXMpIHtcbiAgbGV0IG1pbiA9IHRyYWNlU2VnbWVudEludGVybmFsKHNlZ21lbnRzLCBtZW1vLCBsaW5lLCBjb2x1bW4sIEdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKCFmb3VuZCAmJiBiaWFzID09PSBMRUFTVF9VUFBFUl9CT1VORCkgbWluKys7XG4gIGlmIChtaW4gPT09IC0xIHx8IG1pbiA9PT0gc2VnbWVudHMubGVuZ3RoKSByZXR1cm4gW107XG4gIGNvbnN0IG1hdGNoZWRDb2x1bW4gPSBmb3VuZCA/IGNvbHVtbiA6IHNlZ21lbnRzW21pbl1bQ09MVU1OXTtcbiAgaWYgKCFmb3VuZCkgbWluID0gbG93ZXJCb3VuZChzZWdtZW50cywgbWF0Y2hlZENvbHVtbiwgbWluKTtcbiAgY29uc3QgbWF4ID0gdXBwZXJCb3VuZChzZWdtZW50cywgbWF0Y2hlZENvbHVtbiwgbWluKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAoOyBtaW4gPD0gbWF4OyBtaW4rKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1ttaW5dO1xuICAgIHJlc3VsdC5wdXNoKEdNYXBwaW5nKHNlZ21lbnRbUkVWX0dFTkVSQVRFRF9MSU5FXSArIDEsIHNlZ21lbnRbUkVWX0dFTkVSQVRFRF9DT0xVTU5dKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uKG1hcCwgc291cmNlLCBsaW5lLCBjb2x1bW4sIGJpYXMsIGFsbCkge1xuICB2YXIgX2E7XG4gIGxpbmUtLTtcbiAgaWYgKGxpbmUgPCAwKSB0aHJvdyBuZXcgRXJyb3IoTElORV9HVFJfWkVSTyk7XG4gIGlmIChjb2x1bW4gPCAwKSB0aHJvdyBuZXcgRXJyb3IoQ09MX0dUUl9FUV9aRVJPKTtcbiAgY29uc3QgeyBzb3VyY2VzLCByZXNvbHZlZFNvdXJjZXMgfSA9IG1hcDtcbiAgbGV0IHNvdXJjZUluZGV4MiA9IHNvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuICBpZiAoc291cmNlSW5kZXgyID09PSAtMSkgc291cmNlSW5kZXgyID0gcmVzb2x2ZWRTb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcbiAgaWYgKHNvdXJjZUluZGV4MiA9PT0gLTEpIHJldHVybiBhbGwgPyBbXSA6IEdNYXBwaW5nKG51bGwsIG51bGwpO1xuICBjb25zdCBnZW5lcmF0ZWQgPSAoX2EgPSBjYXN0KG1hcCkpLl9ieVNvdXJjZXMgfHwgKF9hLl9ieVNvdXJjZXMgPSBidWlsZEJ5U291cmNlcyhcbiAgICBkZWNvZGVkTWFwcGluZ3MobWFwKSxcbiAgICBjYXN0KG1hcCkuX2J5U291cmNlTWVtb3MgPSBzb3VyY2VzLm1hcChtZW1vaXplZFN0YXRlKVxuICApKTtcbiAgY29uc3Qgc2VnbWVudHMgPSBnZW5lcmF0ZWRbc291cmNlSW5kZXgyXVtsaW5lXTtcbiAgaWYgKHNlZ21lbnRzID09IG51bGwpIHJldHVybiBhbGwgPyBbXSA6IEdNYXBwaW5nKG51bGwsIG51bGwpO1xuICBjb25zdCBtZW1vID0gY2FzdChtYXApLl9ieVNvdXJjZU1lbW9zW3NvdXJjZUluZGV4Ml07XG4gIGlmIChhbGwpIHJldHVybiBzbGljZUdlbmVyYXRlZFBvc2l0aW9ucyhzZWdtZW50cywgbWVtbywgbGluZSwgY29sdW1uLCBiaWFzKTtcbiAgY29uc3QgaW5kZXggPSB0cmFjZVNlZ21lbnRJbnRlcm5hbChzZWdtZW50cywgbWVtbywgbGluZSwgY29sdW1uLCBiaWFzKTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIEdNYXBwaW5nKG51bGwsIG51bGwpO1xuICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICByZXR1cm4gR01hcHBpbmcoc2VnbWVudFtSRVZfR0VORVJBVEVEX0xJTkVdICsgMSwgc2VnbWVudFtSRVZfR0VORVJBVEVEX0NPTFVNTl0pO1xufVxuZXhwb3J0IHtcbiAgRmxhdHRlbk1hcCBhcyBBbnlNYXAsXG4gIEZsYXR0ZW5NYXAsXG4gIEdSRUFURVNUX0xPV0VSX0JPVU5ELFxuICBMRUFTVF9VUFBFUl9CT1VORCxcbiAgVHJhY2VNYXAsXG4gIGFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcixcbiAgZGVjb2RlZE1hcCxcbiAgZGVjb2RlZE1hcHBpbmdzLFxuICBlYWNoTWFwcGluZyxcbiAgZW5jb2RlZE1hcCxcbiAgZW5jb2RlZE1hcHBpbmdzLFxuICBnZW5lcmF0ZWRQb3NpdGlvbkZvcixcbiAgaXNJZ25vcmVkLFxuICBvcmlnaW5hbFBvc2l0aW9uRm9yLFxuICBwcmVzb3J0ZWREZWNvZGVkTWFwLFxuICBzb3VyY2VDb250ZW50Rm9yLFxuICB0cmFjZVNlZ21lbnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjZS1tYXBwaW5nLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs\n");

/***/ })

};
;